[ { "title": "测试中文NetlifyCMS", "url": "/posts/%E6%B5%8B%E8%AF%95%E4%B8%AD%E6%96%87netlifycms/", "categories": "posts, nothing", "tags": "blog", "date": "2024-01-08 01:33:54 +0000", "snippet": " 读《DARPA 互联网协议的设计理念》有感 文献：David D. Clark. “The Design Philosophy of the DARPA Internet Protocols”, In: Proceedings of ACM SIGCOMM’88, Aug. 1988.论文中讲述了基于TCP/IP协议的DARPA互联网架构的设计理念，包括互联网所要实现的目标（主要目标：互联；二级目标：鲁棒、服务通用、网络通用、分布式管理、低成本高效益、互联便捷、资源可计量，优先级依次递减）和为了实现这些目标所选取的基本架构（分组交换、存储转发）。" }, { "title": "测试netlifyCMS发帖", "url": "/posts/%E6%B5%8B%E8%AF%95netlifycms%E5%8F%91%E5%B8%96/", "categories": "", "tags": "nothing", "date": "2024-01-08 01:05:56 +0000", "snippet": " c﻿an’t write chinese? w﻿hat? ﻿ w﻿hat?" }, { "title": "生信 Week 2 作业", "url": "/posts/bioinfo-hw2/", "categories": "posts, bioinformatics", "tags": "blog", "date": "2022-10-08 11:50:25 +0000", "snippet": "HW2 必做题Blast sequences 请使用网页版的 blastp, 将上面的蛋白序列只与 mouse protein database 进行比对， 设置输出结果最多保留10个， E 值最大为 0.5。将操作过程和结果截图。 注： blast的网站会提供多个mouse的databases，可以任选1个进行比对；也可以重复几次，每次选一个不同的database看看不同的输出结果，可以在作业中比较和讨论一下输出结果不同的原因。 操作： 结果： 请使用 Bash 脚本编程：将上面的蛋白序列随机打乱生成10个， 然后对这10个序列两两之间进行 blast 比对，输出并解释结果。（请上传bash脚本，注意做好重要code的注释；同时上传一个结果文件用来示例程序输出的结果以及你对这些结果的解释。） 完整的代码文件以及生成的结果文件存放在仓库中，和该报告中的内容相同（仓库中多出clone文件夹中的10条随机序列文件、output文件夹中的所有blastp比对结果文件）。 bash脚本： #!/bin/bash # 将原序列文件protein/VIM.fasta的内容读出到header, protein_string中i=0while read line; do if [ \"$i\" -eq 0 ]; then header=\"$line\" else protein_string+=\"$line\" fi i=$((i+1))done &lt; protein/VIM.fasta # 将protein_string字符串按字符存到protein_array数组中while read -n 1 char ; do protein_array+=($char)done &lt;&lt;&lt; \"$protein_string\" # 打乱函数（就地洗牌）function shuffle { local i tmp size rand size=${#protein_array[*]} for ((i=size-1; i&gt;0; i--)); do rand=$(( $RANDOM % (i + 1) )) # swap tmp=${protein_array[i]} protein_array[i]=${protein_array[rand]} protein_array[rand]=$tmp done} # 隔70个字符就换行（fasta文件序列输出美观）function endline { local i size remainer size=${#protein_array[*]} for ((i=0; i&lt;size; i++)); do new_protein_string+=\"${protein_array[$i]}\" remainer=$(( $i % 70 )) if [ $remainer == 69 ]; then new_protein_string+=\"\\n\" fi done} [ ! -d clone ] &amp;&amp; mkdir clone # 随机序列生成在clone文件夹中 total=10 # 生成的随机序列个数为10个 # 将原蛋白序列随机打乱生成total=10个，并存储到fasta文件中for ((i=0; i&lt;$total; i++)); do # 将原蛋白序列随机打乱 shuffle new_header=\"&gt;CLONE$i\" new_protein_string=\"\" output=\"clone/clone$i.fasta\" # 按fasta格式要求存储到文件 endline echo \"${new_header}\" &gt; \"$output\" echo -e \"${new_protein_string}\" &gt;&gt; \"$output\" done # 用blastp进行序列比对，并将结果生成到文件function blast { query=\"clone/clone$1.fasta\" subject=\"clone/clone$2.fasta\" output_blastp=\"output/blastp_$1_$2\" blastp -query $query -subject $subject -out $output_blastp # 核心blastp命令} # 读取并解析blastp生成的结果文件function read_result { local i hit result_file valid_info score expect result_file=\"output/blastp_$1_$2\" valid_info=`grep -A 3 \"&gt; CLONE$2\" $result_file` # 获取\"&gt; CLONE$2\"关键词往后3行内容 # 仅分析结果文件中的Score和Expect hit=0 # 记录query和subject序列是否有hit while read line; do if grep -q \"Score\" &lt;&lt;&lt; \"$line\"; then hit=1 IFS=' ' read -r -a info_array &lt;&lt;&lt; \"$line\" score=${info_array[2]} # Score IFS=',' read -r -a expect_array &lt;&lt;&lt; \"${info_array[7]}\" expect=${expect_array[0]} # Expect fi i=$((i+1)) done &lt;&lt;&lt; \"$valid_info\" # 输出比对的Score和Expect结果到result.txt文件中 if [ $hit -eq 1 ]; then echo \"CLONE$1 vs CLONE$2: Score = $score, Expect = $expect\" &gt;&gt; \"result.txt\" else echo \"CLONE$1 vs CLONE$2: No hit\" &gt;&gt; \"result.txt\" fi} # 对生成的total=10个随机序列两两之间进行blast比对并读取解析结果for ((i=0; i&lt;$total-1; i++)); do for ((j=i+1; j&lt;$total; j++)); do blast $i $j # blast比对 read_result $i $j # 读取解析结果 donedone 结果文件： 需要注意的是，运行bash脚本得到的文件分为三类： 10条随机序列：生成到clone文件夹中，文件命名为clone/clone{id}.fasta，文件格式为fasta格式，header统一为&gt;CLONE{id}，id取值范围是0~9 10条序列两两比对的blastp结果：生成到output文件夹中，文件命名为output/blastp_{query_id}_{subject_id}，为blastp指令自动生成的结果文件，其中query_id和subject_id取值范围是0~9且二者不相等 汇总所有比对的简要结果：将blastp结果文件提取简要信息（最多一条alignment结果的Score和Expect）生成到result.txt文件中 以下只显示第三种，即result.txt文件： CLONE0 vs CLONE1: Score = 17.3, Expect = 1.1CLONE0 vs CLONE2: Score = 15.0, Expect = 5.8CLONE0 vs CLONE3: Score = 18.9, Expect = 0.33CLONE0 vs CLONE4: Score = 17.3, Expect = 1.3CLONE0 vs CLONE5: Score = 17.3, Expect = 1.1CLONE0 vs CLONE6: Score = 16.9, Expect = 1.5CLONE0 vs CLONE7: Score = 15.8, Expect = 3.8CLONE0 vs CLONE8: Score = 21.9, Expect = 0.037CLONE0 vs CLONE9: Score = 14.2, Expect = 9.3CLONE1 vs CLONE2: Score = 19.6, Expect = 0.24CLONE1 vs CLONE3: Score = 16.5, Expect = 1.9CLONE1 vs CLONE4: Score = 16.9, Expect = 1.4CLONE1 vs CLONE5: Score = 18.5, Expect = 0.44CLONE1 vs CLONE6: Score = 16.5, Expect = 2.1CLONE1 vs CLONE7: Score = 16.9, Expect = 1.3CLONE1 vs CLONE8: Score = 16.2, Expect = 2.5CLONE1 vs CLONE9: Score = 18.9, Expect = 0.38CLONE2 vs CLONE3: Score = 15.4, Expect = 4.6CLONE2 vs CLONE4: Score = 18.1, Expect = 0.69CLONE2 vs CLONE5: Score = 17.3, Expect = 1.1CLONE2 vs CLONE6: Score = 16.2, Expect = 2.7CLONE2 vs CLONE7: Score = 19.2, Expect = 0.32CLONE2 vs CLONE8: Score = 17.3, Expect = 1.1CLONE2 vs CLONE9: Score = 17.3, Expect = 1.2CLONE3 vs CLONE4: Score = 16.5, Expect = 2.3CLONE3 vs CLONE5: Score = 15.0, Expect = 5.5CLONE3 vs CLONE6: Score = 16.2, Expect = 2.5CLONE3 vs CLONE7: Score = 18.5, Expect = 0.56CLONE3 vs CLONE8: Score = 17.3, Expect = 1.0CLONE3 vs CLONE9: Score = 16.2, Expect = 2.3CLONE4 vs CLONE5: Score = 18.5, Expect = 0.49CLONE4 vs CLONE6: No hitCLONE4 vs CLONE7: Score = 21.2, Expect = 0.071CLONE4 vs CLONE8: Score = 18.1, Expect = 0.61CLONE4 vs CLONE9: Score = 17.3, Expect = 1.1CLONE5 vs CLONE6: Score = 16.2, Expect = 2.4CLONE5 vs CLONE7: Score = 23.1, Expect = 0.019CLONE5 vs CLONE8: Score = 15.0, Expect = 5.7CLONE5 vs CLONE9: Score = 20.8, Expect = 0.10CLONE6 vs CLONE7: Score = 17.3, Expect = 1.0CLONE6 vs CLONE8: Score = 15.0, Expect = 6.1CLONE6 vs CLONE9: Score = 17.3, Expect = 1.00CLONE7 vs CLONE8: Score = 14.6, Expect = 8.6CLONE7 vs CLONE9: Score = 18.1, Expect = 0.72CLONE8 vs CLONE9: Score = 20.4, Expect = 0.12 对这些结果的解释： 其中将原蛋白序列随机打乱生成的10个新蛋白序列命名为CLONE0~CLONE9，且每两条序列间最多只取一组alignment的评分结果（取Score最高的一条）。对其比对的结果执行排序（优先按Score从大到小排，若Score相同则按Expect从小到大排）： sort -k6nr,6 -k9n,9 'result.txt' 得到排序后的结果： CLONE5 vs CLONE7: Score = 23.1, Expect = 0.019CLONE0 vs CLONE8: Score = 21.9, Expect = 0.037CLONE4 vs CLONE7: Score = 21.2, Expect = 0.071CLONE5 vs CLONE9: Score = 20.8, Expect = 0.10CLONE8 vs CLONE9: Score = 20.4, Expect = 0.12CLONE1 vs CLONE2: Score = 19.6, Expect = 0.24CLONE2 vs CLONE7: Score = 19.2, Expect = 0.32CLONE0 vs CLONE3: Score = 18.9, Expect = 0.33CLONE1 vs CLONE9: Score = 18.9, Expect = 0.38CLONE1 vs CLONE5: Score = 18.5, Expect = 0.44CLONE4 vs CLONE5: Score = 18.5, Expect = 0.49CLONE3 vs CLONE7: Score = 18.5, Expect = 0.56CLONE4 vs CLONE8: Score = 18.1, Expect = 0.61CLONE2 vs CLONE4: Score = 18.1, Expect = 0.69CLONE7 vs CLONE9: Score = 18.1, Expect = 0.72CLONE3 vs CLONE8: Score = 17.3, Expect = 1.0CLONE6 vs CLONE7: Score = 17.3, Expect = 1.0CLONE6 vs CLONE9: Score = 17.3, Expect = 1.00CLONE0 vs CLONE1: Score = 17.3, Expect = 1.1CLONE0 vs CLONE5: Score = 17.3, Expect = 1.1CLONE2 vs CLONE5: Score = 17.3, Expect = 1.1CLONE2 vs CLONE8: Score = 17.3, Expect = 1.1CLONE4 vs CLONE9: Score = 17.3, Expect = 1.1CLONE2 vs CLONE9: Score = 17.3, Expect = 1.2CLONE0 vs CLONE4: Score = 17.3, Expect = 1.3CLONE1 vs CLONE7: Score = 16.9, Expect = 1.3CLONE1 vs CLONE4: Score = 16.9, Expect = 1.4CLONE0 vs CLONE6: Score = 16.9, Expect = 1.5CLONE1 vs CLONE3: Score = 16.5, Expect = 1.9CLONE1 vs CLONE6: Score = 16.5, Expect = 2.1CLONE3 vs CLONE4: Score = 16.5, Expect = 2.3CLONE3 vs CLONE9: Score = 16.2, Expect = 2.3CLONE5 vs CLONE6: Score = 16.2, Expect = 2.4CLONE1 vs CLONE8: Score = 16.2, Expect = 2.5CLONE3 vs CLONE6: Score = 16.2, Expect = 2.5CLONE2 vs CLONE6: Score = 16.2, Expect = 2.7CLONE0 vs CLONE7: Score = 15.8, Expect = 3.8CLONE2 vs CLONE3: Score = 15.4, Expect = 4.6CLONE3 vs CLONE5: Score = 15.0, Expect = 5.5CLONE5 vs CLONE8: Score = 15.0, Expect = 5.7CLONE0 vs CLONE2: Score = 15.0, Expect = 5.8CLONE6 vs CLONE8: Score = 15.0, Expect = 6.1CLONE7 vs CLONE8: Score = 14.6, Expect = 8.6CLONE0 vs CLONE9: Score = 14.2, Expect = 9.3CLONE4 vs CLONE6: No hit 可以看到CLONE5和CLONE7的Score = 23.1、Expect = 0.019比对结果最好。 更进一步查看二者比对的blastp结果文件output/blastp_5_7： Score = 23.1 bits (48), Expect = 0.019, Method: Compositional matrix adjust. Identities = 12/32 (38%), Positives = 18/32 (56%), Gaps = 0/32 (0%) Query 256 SKQLEAPSNSSHIEVVSGRVSNLDYKGTNKRN 287 ++ LE S S I +SG + +L Y G +RNSbjct 158 AQDLEVASQRSDINDLSGILEHLFYNGQMRRN 189 可以看到CLONE5的第256~287处序列SKQLEAPSNSSHIEVVSGRVSNLDYKGTNKRN，和CLONE7的第158~189处序列AQDLEVASQRSDINDLSGILEHLFYNGQMRRN的详细比对结果（打分、E值、一致性、相似率、缺失/插入率，以及具体哪部分序列match或mismatch）。 HW2 练习题" }, { "title": "与时代相互选择，极简所带来的无限可能", "url": "/posts/network-darpa/", "categories": "posts, computer-science", "tags": "blog", "date": "2022-10-06 13:50:00 +0000", "snippet": " 读《DARPA 互联网协议的设计理念》有感 文献：David D. Clark. “The Design Philosophy of the DARPA Internet Protocols”, In: Proceedings of ACM SIGCOMM’88, Aug. 1988.论文中讲述了基于TCP/IP协议的DARPA互联网架构的设计理念，包括互联网所要实现的目标（主要目标：互联；二级目标：鲁棒、服务通用、网络通用、分布式管理、低成本高效益、互联便捷、资源可计量，优先级依次递减）和为了实现这些目标所选取的基本架构（分组交换、存储转发）。在阅读过程中，第一个让我比较有感触的点在于，DARPA设计之初是为了在战争时期服务于军方，预设的通信环境恶劣，因此将最高优先级目标设为鲁棒性（同时将资源计量放在最末），旨在不计代价地聚集资源来实现通信，因此选择了基于端到端原则、命运共享模式的无状态的分组交换技术；若是放在当下的商业环境中，计量计费、低成本高效益等目标肯定优先级会更靠前，设计出来的互联网架构则将截然不同。但即便这一互联网架构看似“过时”，却仍沿用至今、遍布全球，这与用户惯性密不可分。就如同现在我们从IPv4换到IPv6是一个艰难、漫长的过程一样，若要更改已经有了如此庞大体量的互联网架构，只会更加不切实际。因此如今我们所使用的互联网之所以是这般模样，一方面是源自于需求的技术选择，但另一不可忽视的方面是源自于时代选择的机遇性。当然，时代的选择是毕竟还是果，令这一架构成为行业标准的因还是在于其无限的可能性。这也是另一个让我深有感触的点，即网络的架构与实现的辩证性——越简单、限制越少的网络架构，其所具有的工程实现的可能性就丰富、多样。DARPA互联网架构正是如此，它不受限于各种工程实现的可靠性、时延、带宽等具体约束需求，从而造成庞大的体量而无法迁移到不同服务中；而是为了能在工程实现时满足更多服务，通过TCP提供可靠的数据流传输、IP提供可建立多种服务的数据报文协议，因此易于传输、对中继节点的依赖性大幅降低，这样网络结构本身就轻量、不具有冗余，多样的服务需求在工程实现时交付给端系统、网关中基于数据报文的特定算法即可，具有极强的拓展空间。总体而言，现今还在被广泛使用的互联网架构，还是终归要服务于当下时代、满足当下需求，而具体如何满足时代需求，更重要的还是如何具体的应用实现，发挥极简的网络架构所带来的互联网的无限可能。" }, { "title": "生信 Week 2 上机任务", "url": "/posts/bioinfo-class2/", "categories": "posts, bioinformatics", "tags": "blog", "date": "2022-09-23 06:45:25 +0000", "snippet": "写出一个bash脚本，可以使它自动读取一个文件夹（例如bash_homework/）的内容，将该文件夹下文件的名字输出到filenames.txt，子文件夹的名字输出到 dirname.txt。 下载bash_homework.zip并解压。（该文件位于该链接中Files needed by this Tutorial中的清华云Bioinformatics Tutorial / Files路径下的相应文件夹中。） 将bash脚本，filename.txt，dirname.txt 写到同一个文件中上交。格式建议： word, pdf, txt.bash脚本：#!/bin/bash# 提示用户输入待查看文件夹的路径（绝对路径/相对路径）echo -n \"Please input the path of the directory you want to check: \"# 保存用户输入的文件夹路径到check_path中read check_path# 输出文件路径output_file=\"filenames.txt\"output_directory=\"dirname.txt\"for item in ${check_path}/*;do item_name=`basename $item` # 去除目录文件夹前缀${check_path}/ # 若item是文件，则输出该文件名到filenames.txt中 if [ -f $item ];then echo \"$item_name\" &gt;&gt; \"$output_file\" # 若item是子文件夹，则输出该子文件夹的名字到dirname.txt中 elif [ -d $item ];then echo \"$item_name\" &gt;&gt; \"$output_directory\" fi doneexit 0filename.txt：a.txta1.txtb.filter_random.plb1.txtbam_wig.shc.txtc1.txtchrom.sized1.txtdir.txte1.txtf1.txthuman_geneExp.txtif.shimageinsitiue.txtmouse_geneExp.txtname.txtnumber.shout.bwrandom.shread.shtest.shtest.txttest3.shtest4.shwigToBigWigdirname.txt：RBP_mapa-dockerappbackupbinbiosoftc1-RBPannodatatabledbdownloade-annotationexRNAgenomegithighchartshomehub29ibmel-lwlmap2mljsmodulemogprojectnode_modulesperl5postar.dockerpostar2postar_approutscriptscript_backupsoftwaretcgatesttmptmp_scriptvarx-rbp" }, { "title": "生信 Week 1 作业", "url": "/posts/bioinfo-hw1/", "categories": "posts, bioinformatics", "tags": "blog", "date": "2022-09-17 16:32:40 +0000", "snippet": " PART I-2.Liunx-2.2.Practice Guide 提交word/md/txt/sh文件均可 第2，3题要求给出结果，并附上使用的命令 解释1.gtf文件中第4、5列代表什么，exon长度应该是$5-$4+1还是$5-$4？ 第4列start代表基因组起始位置坐标（从1开始，闭区间），第5列end代表基因组终止位置坐标（从1开始，闭区间）。 exon的长度是$5-$4+1。 列出1.gtf文件中 XI 号染色体上的后 10 个 CDS （按照每个CDS终止位置的基因组坐标进行sort）。 结果： # 基因ID 终止位置坐标YKR106W 663286YKR105C 660464YKR104W 657753YKR103W 656733YKR102W 649862YKR101W 642501YKR100C 639968YKR099W 638283YKR098C 635179YKR097W 632798 命令： #!/bin/bashcat 1.gtf | awk '$1 == \"XI\" &amp;&amp; $3 == \"CDS\"' | sort -k 5 -nr | awk '{split($10, x, \";\"); name = x[1]; gsub(\"\\\"\", \"\", name); print name, $5}' | head -n 10 统计 IV 号染色体上各类 feature （1.gtf文件的第3列，有些注释文件中还应同时考虑第2列） 的数目，并按升序排列。 结果： # 出现数目 feature类别853 start_codon853 stop_codon886 gene886 transcript895 CDS933 exon 命令： #!/bin/bashcat 1.gtf |awk '$1 == \"IV\" {print $3}'| sort -n | uniq -c | sort -k 1 -n " }, { "title": "计组实验1：汇编语言与监控程序", "url": "/posts/riscv-homework/", "categories": "posts, computer-science", "tags": "blog", "date": "2022-09-17 14:04:07 +0000", "snippet": "实验报告实验1：RISC-V监控程序与Term命令在模拟器中运行 RISC-V 监控程序的基本步骤如下： 启动监控程序 通过终端连接监控程序 Term 中几个命令的使用方法（以下对每个命令的介绍均来自supervisor-rv/文件夹中的README.md文件）： R：按照 x1 至 x31 的顺序返回用户程序寄存器值。 D：显示从指定地址开始的一段内存区域中的数据。 A：用户输入汇编指令，并放置到指定地址上 F：从文件读入汇编指令并放置到指定地址上，格式与 A 命令相同。 U：从指定地址读取一定长度的数据，并显示反汇编结果。 G：执行指定地址的用户程序。 T：查看页表内容，仅在启用页表时有效。 加上flagEN_PAGING=y来启动监控程序，以启用页表（以下是部分页表内容截图）： Q：退出 Term。 实验2：求前10个Fibonacci数我的代码参考了asmcode/文件夹中sum.s与fib-mem.s代码。其中sum.s中采用循环的方式计算了$1 + 2 + … + 10$，在我的代码中也参考了这一循环loop的书写方式，通过一个计数器t3来控制是否完成了t4 = 10次的计算循环（事实上只需要进行8次循环即可，因为前2项Fib数是既定已给出的，无需计算）。fib-mem.s中比较关键的则是Fib数递推的步骤：根据递推式计算下一个Fib数add t2, t0, t1 # t2 = t0+t1，以及为下一轮递推做准备ori t0, t1, 0x0 # t0 = t1, ori t1, t2, 0x0 # t1 = t2，在我的代码中也参考了这一书写规范来进行Fib数的递推计算。代码的总体思路分为以下几步： 初始化加数（第一个Fib数t0，第二个Fib数t1），并设置好计数器相关变量（已计算次数t3、总共计算次数t4）、待写入地址t5； 将前2个已知Fib数写入当前地址，并更新下一待写入地址； 通过循环，以计算Fib递推式计算下一个Fib数t2 = t0 + t1，并在进入下一轮循环之前更新计算次数t3、待写入地址t5、新一轮递推的加数t0, t1，其中循环的终止条件为t3 == t4（即完成了t4次计算）； 达到循环的终止条件（或不再满足循环的执行条件t3 != t4），返回，程序终止。 .global _start .text_start: li t0, 0x1 # t0 = 1，加数（第1个Fib数） li t1, 0x1 # t1 = 1，加数（第2个Fib数） li t3, 0x2 # 已计算次数，用于计数（前2项已给出） li t4, 0xA # t4 = 10，一共需计算前10个Fib数 li t5, 0x80400000 # 待写入的地址 sw t0, 0x0(t5) # 将第1个Fib数写入地址 sw t1, 0x4(t5) # 将第2个Fib数写入地址 addi t5, t5, 0x8 # 待写入地址自增loop: add t2, t0, t1 # t2 = t0 + t1，Fib数递推式 addi t3, t3, 0x1 # t3++，已计算次数自增 sw t2, 0x0(t5) # 将第t3个Fib数写入地址 addi t5, t5, 0x4 # 待写入地址自增 ori t0, t1, 0x0 # t0 = t1，为新一轮Fib数递推计算做准备 ori t1, t2, 0x0 # t1 = t2，同上 bne t3, t4, loop # 若没算完10个Fib数（t3 != t4），则通过loop继续计算 nop jr ra # 否则（t3 == t4）返回，程序终止 nop在supervisor-rv/kernel/目录下执行make sim启动监控程序，并在supervisor-rv/term/目录下执行python3 term.py -t 127.0.0.1:6666通过终端连接监控程序，并用&gt;&gt; F命令在监控程序中运行以上代码；通过&gt;&gt; D命令查看内存地址0x80400000~0x80400024，结果如下：验证了存入起始地址为0x80400000的10个字中的数（16进制），与前10个Fibonacci数$1, 1, 2, 3, 5, 8, 13, 21, 34, 55$（十进制）一一对应，结果正确。实验3：输出ASCII可见字符我的代码参考了实验说明文档中提供的WRITE_SERIAL、.TESTW、.WSERIAL函数，以实现从终端输出字符。至于输出由0x21~0x7E共94个ASCII可见字符，采用循环的方式（94次循环）来进行输出，其中a0寄存器所存储的既是输出的对象（ASCII可见字符的十六进制编码）、又是计数器（由0x21开始计数到0x7E）。代码的总体思路分为以下几步： 初始化循环开始字符a0、结束字符t2，注意因为执行循环的边界条件判断为“不等”（bne a0, t2, WRITE_SERIAL # a0 != t2 ）而非“小于等于”（a0 &lt;= t2），因此结束字符t2需要额外加一； 通过循环，向终端（0x10000000）输出a0寄存器中的最低字节，并在进入下一轮循环前更新a0的值（a0++，切换到下一顺位ASCII可见字符），其中循环的终止条件为a0 == t2（即完成了由0x21~0x7E所有ASCII可见字符的输出）； 达到循环的终止条件（或不再满足循环的执行条件a0 != t2），返回，程序终止。.section .text.globl _start_start: li a0, 0x21 # 循环开始字符 li t2, 0x7E # 循环结束字符 addi t2, t2, 0x1 # .WSERIAL处bne边界条件WRITE_SERIAL: # 串口地址是 0x10000000 li t0, 0x10000000 # 轮询串口状态（0x10000005）.TESTW: lb t1, 5(t0) # 判断是否可写 andi t1, t1, 0x20 beq t1, zero, .TESTW.WSERIAL: # 向终端（0x10000000）输出 a0 寄存器中的最低字节 sb a0, 0(t0) addi a0, a0, 0x1 # a0++，切换到下一字符以输出 bne a0, t2, WRITE_SERIAL # 若未达到边界条件（a0 != t2）则继续输出ascii字符 nop jr ra # 否则（a0 == t2）返回，终止程序 nop同样启动监控程序，并通过终端连接监控程序，在监控程序中运行以上代码，得到结果：成功向终端输出了ASCII 可见字符：!\"#$%&amp;'()*+,-./0123456789:;&lt;=&gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~实验4：求第60个Fibonacci数与实验2基本一致，但由于第60个Fibonacci数已经超过了32位整型，因此需要在实验2的基础上作出一些修改，主要区别如下： 原先存储Fib数的3个32位寄存器t0、t1、t2，改由6个32位寄存器存储，其中每个64位的整数由2个32位寄存器储存，即{a3, a2}储存第一个Fib数、{a5, a4}储存第二个Fib数、{a1, a0}用来储存由Fib递推式计算得到的下一个Fib数（高位为a3、a5、a1，低位为a2、a4、a0）； 计数器相关变量已计算次数t3保持一致，而总共计算次数t4由10（0xA）改为60（0x3C）； 根据Fib递推式进行的加法运算，由原来的32位整型加法改为64位整型加法，此处参考了实验说明文档中提供的大位宽数据加法的实现方法； 为新一轮Fib数递推计算做准备，赋值时注意要把两个Fib加数的高位、低位寄存器都赋值（因此由原本的两个语句变为四个语句，每个加数各有两个待更新的寄存器需要被赋值）； 只需将第60个Fib数写入制定内存地址即可，因此不再需要每次循环都写入一次地址，而只需要在退出循环之后，执行一次第60个Fib数{a1, a0}的写入即可（注意低位a0写入0x80400000、高位a1写入0x80400004）。 .global _start .text _start: li a1, 0x0 # {a1, a0} = {0, 0}，初始化Fib数和 li a0, 0x0 li a3, 0x0 # {a3, a2} = {0, 1}，初始化Fib数加数（第1个Fib数为1） li a2, 0x1 li a5, 0x0 # {a5, a4} = {0, 1}，初始化Fib数加数（第2个Fib数为1） li a4, 0x1 li t3, 0x2 # 已计算次数，用于计数（前2项已给出） li t4, 0x3C # t4 = 60，需计算到第60个Fib数 li t5, 0x80400000 # 待写入的地址loop: # {a3, a2} 即把低位保存在 a2，高位保存在 a3 的 64 位整数 # {a3, a2} + {a5, a4} = {a1, a0} add a0, a2, a4 sltu a2, a0, a2 add a1, a3, a5 add a1, a2, a1 addi t3, t3, 0x1 # t3++，已计算次数自增 ori a3, a5, 0x0 # {a3, a2} = {a5, a4}，为新一轮Fib数递推计算做准备 ori a2, a4, 0x0 ori a5, a1, 0x0 # {a5, a4} = {a1, a0}，同上 ori a4, a0, 0x0 bne t3, t4, loop # 若没算到第60个Fib数（t3 != t4），则通过loop继续计算 nop sw a0, 0x0(t5) # 否则（t3 == t4）将第60个Fib数{a1, a0}写入地址 sw a1, 0x4(t5) jr ra # 返回，程序终止 nop同样启动监控程序，并通过终端连接监控程序，在监控程序中运行以上代码（方法与实验2、3均一致，此处省略），得到结果：存入内存的结果0x1686c8312d0（十六进制）与第60个Fib数1548008755920（十进制）相同，结果正确。代码分析报告虽然在supervisor-rv/README.md文件中的“介绍”章节中写到“监控程序分为两个部分，Kernel和Term”，但鉴于实验说明文档中的要求是“撰写监控程序以及终端程序的代码分析报告”，以下均以实验说明文档中的说法为准，即监控程序代表Kernel、终端程序代表Term，而README.md文档中的“监控程序Supervisor”本质为一个简化的“操作系统”（即操作系统Supervisor分为监控程序Kernel和终端程序Term两个部分）。在本次实验中，监控程序Kernel被运行在模拟环境QEMU中（QEMU模拟了RISC-V指令与系统，在后续实验中模拟环境QEMU将被物理实验平台替代），而我们需要通过终端程序Term与模拟环境QEMU中的监控程序Kernel进行交互，具体交互流程将在后续交互流程一节中阐释。以下将先分别给出监控程序Kernel与终端程序Term的代码分析。监控程序Kernel监控程序Kernel的代码在supervisor-rv/kernal/文件夹中：.├── Makefile（编译规则）├── debug（调试指令）├── include（头文件）│ ├── common.h（基本信息如使用32位或64位架构使用的访存指令与地址位数、用户栈初始化、各信号相关常量等）│ ├── exception.h（异常相关的常量）│ └── serial.h（串口相关的常量）├── kern（监控程序Kernel核心代码！！！）│ ├── evec.S（监控程序入口点）│ ├── init.S（监控程序初始化）│ ├── kernel32.ld（32位RISC-V的链接文件）│ ├── kernel64.ld（64位RISV-V的链接文件）│ ├── shell.S（监控程序的交互功能实现）│ ├── test.S（监控程序的性能测试程序）│ ├── trap.S（监控程序中涉及中断相关代码）│ └── utils.S（通过串口进行读、写数据相关代码）├── kernel.asm（make编译Kernel程序后生成的文件）├── kernel.bin（make编译Kernel程序后生成的文件）├── kernel.elf（make编译Kernel程序后生成的文件）└── obj/（内含make编译Kernel程序后生成的文件）核心代码均在kern/文件夹中，其中涉及到本次实验基础版本Kernel的文件为 evec.S 、 init.S 、 shell.S 、 utils.S 这4个文件。程序的结构为：graph TD\t\tsubgraph evec.S\t\t\t\tsubgraph INITLOCATE\t\t\t\t\t\tA[Kernel入口, 跳转到init.S: START]\t\t\t\tend\t\tend\t\tA --&gt; C\t\tsubgraph init.S\t\t\t\tsubgraph START C[清空BSS段, 设置内核栈+用户栈+用户态程序sp和fp寄存器] --&gt; D[配置串口等] D --&gt; D1[配置中断帧]\t\t\t\tend\t\t\t\tsubgraph WELCOME\t\t\t\t\t\tD1 --&gt; D2[装入启动信息并打印]\t\t\t\t\t\tD3[跳转到shell.S: SHELL, 开始交互]\t\t\t\t\t\t\t\t\t\tend\t\tend\t\t\t\tD3 --&gt; E\t\t\t\tsubgraph utils.S\t\t\t\tsubgraph WRITE_SERIAL_STRING\t\t\t\t\t\tD2 --&gt; H[写字符串: 将a0地址开始处的字符串写入串口]\t\t\t\t\t\tH --&gt; H1[调用串口写函数]\t\t\t\t\t\t\tG[打印循环至 0 结束符]\t\t\t\tend\t\t\t\t\t\t\t\tsubgraph WRITE_SERIAL\t\t\t\t\t\tH1 --&gt; H2[写串口: 将a0的低八位写入串口]\t\t\t\t\t\tH2 --&gt; H3[检测验证: 截取并查看串口状态的写状态位]\t\t\t\t\t\tH3 --&gt;|非零可写, 进入写|H3_1[写入寄存器a0中的值]\t\t\t\t\t\tH3 --&gt;|为零不可写, 忙等待|H3\t\t\t\t\t\tH3_1 --&gt; G\t\t\t\t\t\tG --&gt; D3\t\t\t\tend\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tsubgraph READ_SERIAL\t\t\t\t\t\tF[读串口: 将读到的数据写入a0低八位]\t\t\t\t\t\tF --&gt; F1[检测验证: 截取并查看串口状态的读状态位]\t\t\t\t\t\tF1 --&gt;|非零可读, 进入读|F1_1[将串口中的值读取到寄存器a0]\t\t\t\t\t\tF1 --&gt;|为零不可读, 忙等待|F1\t\t\t\tend\t\tend\t\t\t\t\t\t\t\tsubgraph shell.S\t\t\t\tsubgraph SHELL\t\t\t\t\t\tE[调用串口读函数, 读取操作符] --&gt; F\t\t\t\t\t\tF1_1 --&gt; I[根据操作符进行不同的操作]\t\t\t\t\t\t\t\t\t\t\t\tI --&gt;|'R'|OP_R\t\t\t\t\t\tI --&gt;|'D'|OP_D\t\t\t\t\t\tI --&gt;|'A'|OP_A\t\t\t\t\t\tI --&gt;|'G'|OP_G\t\t\t\t\t\tI --&gt;|'T'|OP_T\t\t\t\t\t\tI --&gt;|其他, 主要指'W'|OP_OTHER\t\t\t\t\t\t\t\t\t\t\t\tsubgraph .OP_R\t\t\t\t\t\t\t\tOP_R[打印用户空间寄存器]\t\t\t\t\t\tend\t\t\t\t\t\t\t\t\t\t\t\tsubgraph .OP_D\t\t\t\t\t\t\t\tOP_D[打印内存num个字节]\t\t\t\t\t\tend\t\t\t\t\t\t\t\t\t\t\t\tsubgraph .OP_A\t\t\t\t\t\t\t\tOP_A[写入内存num字节, num为4的倍数]\t\t\t\t\t\tend\t\t\t\t\t\t\t\t\t\t\t\tsubgraph .OP_G\t\t\t\t\t\t\t\tOP_G[跳转到用户程序执行]\t\t\t\t\t\tend\t\t\t\t\t\t\t\t\t\t\t\tsubgraph .OP_T\t\t\t\t\t\t\t\tOP_T[打印页表] \t\t\t\t\t\tend\t\t\t\t\t\t\t\t\t\t\t\tsubgraph OTHER[错误反馈]\t\t\t\t\t\t\t\tOP_OTHER[把XLEN写给term] \t\t\t\t\t\tend\t\t\t\t\t\t\t\t\t\t\t\tOP_R --&gt; E\t\t\t\t\t\tOP_D --&gt; E\t\t\t\t\t\tOP_A --&gt; E\t\t\t\t\t\tOP_G --&gt; E\t\t\t\t\t\tOP_T --&gt; E\t\t\t\t\t\tOP_OTHER --&gt; E\t\t\t\t\t\t\t\t\t\tend\t\tend\t\t由于shell.S中的具体操作（R、D、A、G、T）繁多，在上图中不一一分析具体实现方法，只取比较核心的G运行用户代码操作做详细分析，其代码结构如下（所有的循环i = 0, 1, 2, 3均是为了报告中书写方便，在实际代码中采用了直接书写四次代码实现）：graph TD\t\tsubgraph shell.S\t\t\t\tsubgraph .OP_G\t\t\t\t\t\tOP_G1[获取用户程序地址]\t\t\t\t\t\tOP_G2[从a0保存用户地址到s10]\t\t\t\t\t\tOP_G2 --&gt; OP_G3[写开始计时信号SIG_TIMERSET到串口, 通知Term开始运行]\t\t\t\t\t\tOP_G4[定位用户空间寄存器备份地址] --&gt; OP_G5[恢复用户程序调用前的寄存器数据]\t\t\t\t\t\tOP_G5 --&gt; OP_G6[重新获得当前监控程序栈顶指针]\t\t\t\t\t\tOP_G6 --&gt; OP_G7[写停止计时信号SIG_TIMETOKEN到串口, 通知Term结束计时, 调用WRITE_SERIAL过程与前述写SIG_TIMERSET一致, 此处省略]\t\t\t\tend\t\tend\t\t\t\tOP_G1 --&gt; READ1\t\tOP_G3 --&gt; WRITE\t\t\t\tsubgraph utils.S\t\t\t\tsubgraph READ_SERIAL_XLEN\t\t\t\t\t\tREAD1[调用READ_SERIAL_WORD函数]\t\t\t\tend\t\t\t\t\t\t\t\tREAD1 --&gt; READ2\t\t\t\t\t\t\t\tsubgraph READ_SERIAL_WORD\t\t\t\t\t\tREAD2[保存ra, s0-s3]\t\t\t\t\t\tREAD4[结果存入si, i++]\t\t\t\t\t\tREAD5[截取s0-s3的低8位] --&gt;|第i次, i=0,1,2,3|READ6[存si的高8位到a0中, 再左移8位, i++]\t\t\t\t\t\tREAD6 --&gt;|i&lt;4|READ6\t\t\t\t\t\tREAD6 --&gt;|i&gt;=4|READ7[通过ra保存的返回地址返回]\t\t\t\tend\t\t\t\t\t\t\t\tREAD2 --&gt;|调用第i次, i=0,1,2,3|READ3\t\t\t\t\t\t\t\tsubgraph READ_SERIAL\t\t\t\t\t\tREAD3[读串口获得8位数据]\t\t\t\tend\t\t\t\t\t\t\t\tREAD3 --&gt; READ4\t\t\t\tREAD4 --&gt;|i&lt;4|READ3\t\t\t\tREAD4 --&gt;|i&gt;=4|READ5\t\t\t\tREAD7 --&gt; OP_G2\t\t\t\t\t\t\t\tsubgraph WRITE_SERIAL\t\t\t\t\t\tWRITE[检测验证+写串口, 同前述过程, 此处省略]\t\t\t\tend\t\t\t\t\t\t\t\tWRITE --&gt; OP_G4\t\t\t\t\t\tend\t\t\t\t终端程序Term终端程序的代码在supervisor-rv/term/term.py文件中，程序的结构为：graph TD\t\tsubgraph main\t\t\t\tmain2[设置命令行参数] \t\t\t\tmain3[初始化失败, 程序终止]\t\t\t\tmain4[初始化成功, 进入Main函数]\t\tend\t\t\t\tmain2 --&gt;|检测tcp|TCP0.5\t\tmain4 --&gt; Main1\t\t\t\tsubgraph InitializeTCP\t\t\t\tTCP0[创建tcp_wrapper类的服务器ser]--&gt;TCP0.5[连接kernel, 设置inp, outp]\t\tend\t\t\t\tTCP0.5 --&gt; TCP1\t\t\t\tsubgraph tcp_wrapper\t\t\t\tsubgraph connect\t\t\t\t\t\tTCP1[通过python的stdlib中的socket模块connect函数, 连接TCP服务器kernel的host+port]\t\t\t\tend\t\t\t\t\t\t\t\tsubgraph read\t\t\t\t\t\tTCP_read[通过stdlib中的socket模块recv函数, 8位8位读取串口数据]\t\t\t\tend\t\t\t\t\t\t\t\tsubgraph write\t\t\t\t\t\tTCP_write[通过stdlib中的socket模块send函数, 8位8位写入串口数据]\t\t\t\tend\t\tend\t\t\t\tTCP1 --&gt;|连接成功|main3 TCP1 --&gt;|连接失败|main4\t\t\t\tMain0 --&gt; TCP_read\t\tTCP_read --&gt; Main1\t\tsubgraph Main\t\t\t\tMain0[通过inp.read读取串口, 获得kernel发来的欢迎信息与xlen信息]\t\t\t\tMain1[输出, 并进入MainLoop函数]\t\tend\t\t\t\tMain1 --&gt; ML1\t\tsubgraph Mainloop\t\t\t\tML1[根据用户在命令行中的指令cmd, 执行不同操作]\t\t\t\t ML1--&gt;|'A'|A ML1--&gt;|'F'|F ML1--&gt;|'R'|R ML1--&gt;|'D'|D ML1--&gt;|'U'|U ML1--&gt;|'G'|G ML1--&gt;|'T'|T ML1--&gt;|'Q'|Q subgraph run_A A[用户输入汇编指令, 并放置到指定地址上] end subgraph run_F F[从文件读入汇编指令并放置到指定地址上] end subgraph run_R R[返回用户程序寄存器值] end subgraph run_D D[显示从指定地址开始的一段内存区域中的数据] end subgraph run_U U[从指定地址读取一定长度的数据, 并显示反汇编结果] end subgraph run_G G[执行指定地址的用户程序] end subgraph run_T T[查看页表内容, 仅在启用页表时有效] end Q[退出Term] A--&gt;ML2 F--&gt;ML2 R--&gt;ML2 D--&gt;ML2 U--&gt;ML2 G--&gt;ML2 T--&gt;ML2 ML2[通过outp.write写入串口, 通知kernel执行该命令]--&gt;TCP_write TCP_write --&gt; ML1\t\tend交互流程Kernel和Term通过串口进行交互，即用户在Term中输入的命令、代码在经过 Term 处理后通过串口传输给 Kernel，而Kernel需要输出的信息也会通过串口传输到Term并展示给用户。在这里是使用QEMU模拟串口，其地址如README.md文件所描述的： 设置了一个内存以外的地址区域，用于串口收发。串口控制器按照 16550 UART 的寄存器 的子集实现，访问的代码位于 kern/utils.S ，其部分数据格式为： 地址 位 说明 COM1 = 0x10000000 [7:0] 串口数据，读、写地址分别表示串口接收、发送一个字节 COM1 + COM_LSR_OFFSET = 0x10000005 [5] 只读，为1时表示串口空闲，可发送数据 COM1 + COM_LSR_OFFSET = 0x10000005 [0] 只读，为1时表示串口收到数据 意思是不论是Kernel要读写数据（从/给Term读/写），还是Term要读写数据（从/给Kernel读/写），二者均需要在判断0x10000005地址处的相关检验位（可写位是第5位，可读位是第0位）为1时，从0x10000000读/写8位的数据。一个重要的例子是，在前面针对监控程序Kernel的代码分析中，分析过的Term向Kernel发送用户代码的32位地址数据时（Term写、Kernel读），二者均需在判断可写/读时每次仅进行8位的数据交互，共4次，Kernel读到这4个8位的数据还需通过依次放入目标寄存器再左移的方法复原32位数据，实现完整的32位地址数据交互。在Kernel中交互主要的代码块在utils.S中，包含向串口写入数据的 WRITE_SERIAL 、 WRITE_SERIAL_WORD 、 WRITE_SERIAL_XLEN 、 WRITE_SERIAL_STRING 函数，以及从串口读入数据的 READ_SERIAL 、 READ_SERIAL_WORD 、 READ_SERIAL_XLEN 函数。其中 WRITE_SERIAL_WORD 、 WRITE_SERIAL_XLEN 、 WRITE_SERIAL_STRING 均是基于 WRITE_SERIAL 函数（内部根据写出的数据大小，选择调用对应次数的 WRITE_SERIAL 函数），READ_SERIAL_WORD 、 READ_SERIAL_XLEN 均是基于 READ_SERIAL 函数（内部根据读入的数据大小，选择调用对应次数的 WRITE_SERIAL 函数）。对于串口地址、串口检验地址等常量均定义在include/serial.h中。而 WRITE_SERIAL 和 READ_SERIAL 的核心内容，总结如下： 判断检验位：将判断地址0x10000005处的数据通过lb指令读到t1寄存器中，再通过andi运算（WRITE_SERIAL中为t1 = t1 &amp; COM_LSR_THRE = t1 &amp; 0x20 即 t1 = t1 &amp; 0b00100000截取第5位检验位是否可写；READ_SERIAL中为t1 = t1 &amp; COM_LSR_DR = t1 &amp; 0x01即 t1 = t1 &amp; 0b00000001截取第1为检验位是否可读）截取检验位并判断是否可写/可读（可写/可读计算为1，不可写/不可读为0）； 根据检验位的合法性决定下一步执行动作（条件跳转bne）：若检验位不合法（为0）则通过循环判断检验位代码的方法实现“忙等待”，不断“轮询串口状态”直到合法（为1）；若检验位合法（为1）则直接顺序执行后面的代码（真正执行读/写到串口的代码）； 读/写：通过sb（WRITE_SERIAL，写）、lb（READ_SERIAL，读）向/从串口地址0x10000000读/写数据。这种通过 sb、lb 等内存访问指令来实现的对于串口的访问，实际是访问的外设寄存器，这种访问方式叫做MMIO（内存映射 IO）。在Term中交互主要的代码块在term.py文件里class tcp_wrapper中定义的write函数与read函数，函数实现是基于Python的stdlib库中socket模块的send、recv函数。虽然不确定socket模块的send、recv函数具体是如何实现的，但根据Kernel在utils.S中的读 READ_SERIAL /写 WRITE_SERIAL 函数每次只读取/写入0x10000000地址8位数据，推测Term中调用的socket模块的send、recv函数也需要判断检验位后每次向串口地址0x10000000读/写8位数据。思考题目 比较 RISC-V 指令寻址方法与 x86 指令寻址方法的异同。 RISC-V指令寻址方法只有一种（立即数与存放基址的寄存器相加，即基址+偏移量寻址），而x86指令寻址方法繁多（包含立即数寻址、寄存器寻址、绝对寻址、间接寻址、基址+偏移量寻址、2种变址寻址、4种比例变址寻址）。 RISC-V只有load, store访存指令（lb, lw, sb, sw等）可以访问内存，而x86基本所有指令（如移动指令mov、算术指令add等，以及x86本身的访存指令）均可以访问内存。 阅读监控程序，列出监控程序的 19 条指令，请根据自己的理解对用到的指令进行分类，并说明分类原因。 19条指令（参考了《RISC-V手册》）： 指令 描述 具体含义 add rd, rs1, rs2 x[rd] = x[rs1] + x[rs2] 把寄存器 x[rs2]加到寄存器x[rs1]上，结果写入x[rd]（忽略算术溢出） addi rd, rs, imm x[rd] = x[rs] + sext(imm) 把符号位扩展的立即数加到寄存器x[rs]上，结果写入x[rd]（忽略算术溢出） and rd, rs1, rs2 x[rd] = x[rs1] &amp; x[rs2] 将寄存器 x[rs1]和寄存器x[rs2]位与的结果写入x[rd] andi rd, rs, imm x[rd] = x[rs] &amp; sext(imm) 把符号位扩展的立即数和寄存器x[rs]上的值进行位与，结果写入x[rd] auipc rd, imm x[rd] = pc + sext(imm[31:12] « 12) 把符号位扩展的20位（左移12位）立即数加到pc上，结果写入x[rd] beq rs1, rs2, offset if (x[rs1] == x[rs2]) pc += sext(offset) 若寄存器x[rs1]和寄存器x[rs2]的值相等，把pc的值设为当前值加上符号位扩展的偏移offset bne rs1, rs2, offset if (x[rs1] ≠ x[rs2]) pc += sext(offset) 若寄存器x[rs1]和寄存器x[rs2]的值不相等，把pc的值设为当前值加上符号位扩展的偏移offset jal rd, offset x[rd] = pc+4; pc += sext(offset) 把下一条指令的地址(pc+4)写入x[rd]，然后把pc设置为当前值加上符号位扩展的offset jalr rd, offset(rs) t=pc+4; pc=(x[rs]+sext(offset))&amp;~1; x[rd]=t 把pc设置为x[rs]+sext(offset)，把计算出的地址的最低有效位设为 0，并将原pc+4的值写入x[rd]（rd默认为x1） lb rd, offset(rs) x[rd] = sext(M[x[rs] + sext(offset)][7:0]) 从地址x[rs]+sext(offset)读取一个字节（8位），经符号位扩展后写入x[rd] lui rd, imm x[rd] = sext(imm[31:12] « 12) 将符号位扩展的20位立即数imm左移12位，写入x[rd]中（低12位置零） lw rd, offset(rs) x[rd] = sext(M[x[rs] + sext(offset)][31:0]) 从地址x[rs]+sext(offset)读取四个字节，写入x[rd] or rd, rs1, rs2 x[rd] = x[rs1] | x[rs2] 把寄存器x[rs1]和寄存器x[rs2]按位取或，结果写入x[rd] ori rd, rs, imm x[rd] = x[rs] | sext(imm) 把寄存器x[rs]和符号扩展的立即数imm按位取或，结果写入x[rd] sb rs2, offset(rs1) M[x[rs1] + sext(offset)] = x[rs2][7:0] 将x[rs2]的低8位存入内存地址x[rs1]+sext(offset) slli rd, rs, shamt x[rd] = x[rs] « shamt 把寄存器x[rs]逻辑左移shamt位，空出的位置填入0，结果写入x[rd]（对于RV32I，仅当shamt[5]=0时，指令才有效） srli rd, rs, shamt x[rd] = x[rs] » shamt 把寄存器x[rs]逻辑右移shamt位，空出的位置填入0，结果写入x[rd]（对于RV32I，仅当shamt[5]=0时，指令才有效） sw rs2, offset(rs1) M[x[rs1] + sext(offset)] = x[rs2][31:0] 将x[rs2]的低位4个字节存入内存地址x[rs1]+sext(offset) xor rd, rs1, rs2 x[rd] = x[rs1] ^ x[rs2] x[rs1]和x[rs2]按位异或，结果写入x[rd] x[id]表示编号为id的寄存器，rd表示destination register目标寄存器的编号，rs表示source register源寄存器的编号，sext表示sign-extend符号位扩展，imm表示immediate立即数，pc表示program counter程序计数器寄存器，offset为立即数形式的偏移量，M[address]表示地址为address的内存空间，shamt为立即数形式的位移量。 分类： 分类 指令 原因 整数计算指令 ADD, ADDI, AND, ANDI, SLLI, SRLI, OR, ORI, XOR, LUI, AUIPC 需要调用ALU，包含算术指令（ADD, ADDI）、逻辑指令（AND, ANDI, OR, ORI, XOR）、移位指令（SLLI, SRLI）、其他（向PC高位加上立即数的AUIPC, 加载立即数到高位的LUI） 条件分支指令 BEQ, BNE 根据比较结果进行分支跳转 无条件跳转指令 JAL, JALR 实现无条件的跳转并链接 访存指令 LB, LW, SB, SW 从/向内存加载、存储数据 结合 term 源代码和 kernel 源代码说明 term 是如何实现用户程序计时的。 主要思路是，Kernel获得用户程序地址后通过串口发送开始计时信号SIG_TIMERSET来通知Term用户程序开始运行，Term处开始计时（记录开始时间），Kernel执行完用户程序并复原调用用户代码前的寄存器、栈顶指针后通过串口发送停止计时信号SIG_TIMETOKEN来通知Term用户程序结束运行，Term处停止计时并获得用户程序运行时间（计算结束时间与先前记录的开始时间之差）。 具体流程为： Term在term.py文件中的run_G函数中，将指令G与用户程序代码所在的8位内存地址通过串口写给Kernel； Kernel在shell.S文件的SHELL函数中从串口中读入Term发来的G指令并跳转到.OP_G子函数中，再从串口中读入Term发来的用户程序代码所在的8位内存地址并保存到s10寄存器，然后在执行用户程序（跳转到s10所存内存地址处）之前，通过串口向Term写入开始计时信号SIG_TIMERSET（即0x06，在ASCII中表示ACK，为不可见ASCII字符）； Term通过串口读入Kernel发来的数据，并判断是否为约定好的开始计时信号SIG_TIMERSET（即0x06），若是则通过time_start = timer()开始计时（记录开始时间）； Kernel此时写入返回地址la ra, .USERRET2到ra后开始执行用户程序，即jr s10跳转到用户程序所在的内存地址s10处，同时Term通过while True:循环不断判断从串口处读入的数据是否是约定好的停止计时信号SIG_TIMETOKEN（即0x07，在ASCII中表示BEL，为不可见ASCII字符）—— 若Term读入的不是停止计时信号SIG_TIMETOKEN（且也不是超时信号SIG_TIMEOUT即0x81 ）则默认为Kernel向Term发送的待输出到终端的可见字符，调用output_binary函数将其输出到终端； 直到Kernel执行完用户程序（进入.USERRET2子函数并完成调用用户程序之前的寄存器、栈顶指针复原），通过串口向Term写入停止计时信号SIG_TIMETOKEN； 因此此时Term再通过while循环从串口读入的就是停止计时信号SIG_TIMETOKEN（即0x07），终止while循环并通过elapse = timer() - time_start停止计时并获得用户程序运行时间（计算结束时间与先前记录的开始时间之差）。 说明 kernel 是如何使用串口的（在源代码中，这部分有针对 FPGA 与 QEMU 两个版本的代码，任选其一进行分析即可）。 如supervisor-rv/kernel/include/serial.h文件中定义的，FPGA与QEMU的串口地址常量均由COM1表示、串口的寄存器地址间隔均由COM_MULTIPLY表示、串口是否可读/可写的判断地址相对于串口地址的偏移量均由COM_LSR_OFFSET表示（即判断可读/可写状态位的判断地址实际为COM1 + COM_LSR_OFFSET）、写状态位均由COM_LSR_THRE表示、读状态位均由COM_LSR_DR表示。 详见上一章代码分析报告中交互流程一节，以QEMU为例（即COM1 = 0x10000000, COM_MULTIPLY = 1, ` COM_LSR_OFFSET = 5, COM_LSR_THRE = 0x20, COM_LSR_DR = 0x01）分析了Kernel如何使用串。（FPGA相应的各常量为COM1 = AXI Uart16550的基地址 + 0x10000, COM_MULTIPLY = 4, COM_LSR_OFFSET = 20, COM_LSR_THRE = 0x20, COM_LSR_DR = 0x01`）。 请问 term 如何检查 kernel 已经正确连入，并分别指出检查代码在 term 与 kernel 源码中的位置。 检查代码在Term源码中的term.py文件main函数调用InitializeTCP函数中ser.connect(host, int(port))语句，其中ser是类tcp_wrapper的对象，tcp_wrapper的成员函数connect内部实际上调用了Python的stdlib库中socket模块所定义的connect函数。 检查代码在Kernel源码中的shell.S文件SHELL函数li a0, XLEN与jal WRITE_SERIAL指令（后续又跳转到utils.S文件WRITE_SERIAL函数以将XLEN写入串口给Term）。 Term如何检查Kernel已经正确连入，分析如下—— 观察Term连接Kernel的过程： ➜ kernel git:(master) ✗ make simriscv64-unknown-elf-ld obj/evec.o obj/init.o obj/shell.o obj/test.o obj/trap.o obj/utils.o -Tkern/kernel32.ldqemu-system-riscv32 -M virt -m 32M -kernel kernel.elf -nographic -monitor none -serial tcp::6666,server -s -bios noneqemu-system-riscv32: -serial tcp::6666,server: info: QEMU waiting for connection on: disconnected:tcp::::6666,server=on ➜ term git:(master) ✗ python3 term.py -t 127.0.0.1:6666connecting to 127.0.0.1:6666...connectedMONITOR for RISC-V - initialized.running in 32bit, xlen = 4&gt;&gt; 完整连接过程（包含检查是否正确连入）分为以下几步： 一旦启动Kernel（执行make sim指令），Kernel就已经完成evec.S与init.S中代码的运行（此处包含①各种必要的初始化，②通过模拟器QEMU设置好的host为本机、端口为6666的TCP服务器以等待Term的连接并配置好串口，③以及向串口写入定义为monitor_version的文本数据\"MONITOR for RISC-V - initialized.\"——注意此处只是向串口写入，Term并没有读取该数据，Term甚至还没有连接上Kernel呢），并进入shell.S中SHELL函数中，第一行的jal READ_SERIAL跳转到utils.S的读操作符函数中，忙等待Term在连接上Kernel之后通过串口向Kernel发送操作符W，好让Kernel通过串口把XLEN写给Term（注意此处Kernel一直卡在函数READ_SERIAL中的子函数.TESTR进行轮询检测验证，因为Term此时还没给Kernel发送任何数据，因此串口检测地址的可读位始终为0，Term甚至还没连接上Kernel呢）； 反观Term，由用户在终端敲入python3 term.py -t 127.0.0.1:6666命令，Term在term.py的main函数中通过args = parser.parse_args()从命令行读入args.tcp = 127.0.0.1:6666 ，并作为参数host_port传入InitializeTCP(host_port)函数； 在InitializeTCP函数中，若用户输入的host_port不满足host与port的正则表达式，则直接返回到main函数中输出print('Failed to establish TCP connection')退出程序，也就是完全没有执行任何连接相关操作； 若用户输入的host_port在语法上是合法的，则Term创建tcp_wrapper类的ser = tcp_wrapper()对象，在终端输出\"connecting to 127.0.0.1:6666...\"，并调用socket模块（Python的stdlib库自带模块）的ser.connect(host, int(port))连接函数进行连接与检查是否正确连入的操作（若连接成功则顺序执行print(\"connected\")输出连接成功，若连接失败则由socket库的connect函数提供报错信息如ConnectionRefusedError: [Errno 61] Connection refused并退出程序）； 连接成功后（终端输出\"connected\"），Term跳转到Main函数，通过inp.read从串口中读入步骤1.中Kernel往串口中写入的monitor_version文本数据，并打印在终端； 然后Term再向串口outp.write(b'W')写入操作符W，如步骤1.所提到的，Kernel在READ_SERIAL函数中的子函数.TESTR轮询进行检测验证，终于验证到了可读位为1（因为Term终于向Kernel发送了数据W，串口检测地址的可读位从0变成1），顺序执行读取操作符W，并返回到SHELL函数中，执行li a0, XLEN与jal WRITE_SERIAL，即将机器字长XLEN（版本号）通过串口写给Term，该功能作为检查是否正确连入的标志，之后Kernel将等待Term从串口发来的Term命令； Term读取串口xlen = ord(inp.read(1))获得机器字长并输出到终端\"running in 32bit, xlen = 4\"，随后进入MainLoop函数由用户输入Term命令，后续再与Kernel交互，不再阐释。 " }, { "title": "首条博客：网站创建成功~", "url": "/posts/first-blog/", "categories": "posts, nothing", "tags": "blog", "date": "2022-09-17 12:54:07 +0000", "snippet": "并没有什么内容的博客哈哈，贴一下老师的作业要求吧！ 注册一个GitHub账户，创建一个repo(仓库)，写好README.md。尝试使用Git（初学者可以用github的桌面版软件）管理自己的代码并同步GitHub云端和本地文件。 尝试使用Markdown语言，熟悉其语法，利用github的github page功能，用markdown写一个自己的网页。 " } ]
