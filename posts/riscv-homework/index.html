<!DOCTYPE html><html lang="en" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.2.2" /><meta property="og:title" content="计组实验1：汇编语言与监控程序" /><meta name="author" content="Hanna Wang" /><meta property="og:locale" content="en" /><meta name="description" content="实验报告" /><meta property="og:description" content="实验报告" /><link rel="canonical" href="https://hanna0911.github.io/posts/riscv-homework/" /><meta property="og:url" content="https://hanna0911.github.io/posts/riscv-homework/" /><meta property="og:site_name" content="Hanna’s Site" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2022-09-17T14:04:07+00:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="计组实验1：汇编语言与监控程序" /><meta name="twitter:site" content="@twitter_username" /><meta name="twitter:creator" content="@Hanna Wang" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Hanna Wang","url":"https://github.com/hanna0911"},"dateModified":"2022-10-08T12:01:53+00:00","datePublished":"2022-09-17T14:04:07+00:00","description":"实验报告","headline":"计组实验1：汇编语言与监控程序","mainEntityOfPage":{"@type":"WebPage","@id":"https://hanna0911.github.io/posts/riscv-homework/"},"url":"https://hanna0911.github.io/posts/riscv-homework/"}</script><title>计组实验1：汇编语言与监控程序 | Hanna's Site</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Hanna's Site"><meta name="application-name" content="Hanna's Site"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener("change", () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } } /* ModeToggle */ const toggle = new ModeToggle(); function flipMode() { if (toggle.hasMode) { if (toggle.isSysDarkPrefer) { if (toggle.isLightMode) { toggle.clearMode(); } else { toggle.setLight(); } } else { if (toggle.isDarkMode) { toggle.clearMode(); } else { toggle.setDark(); } } } else { if (toggle.isSysDarkPrefer) { toggle.setLight(); } else { toggle.setDark(); } } toggle.notify(); } /* flipMode() */ </script><body data-spy="scroll" data-target="#toc" data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" class="mx-auto"> </a></div><div class="site-title mt-3"> <a href="/">Hanna's Site</a></div><div class="site-subtitle font-italic">A text-focused blog</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/hanna0911" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['hanna0911','qq.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper"><div id="topbar" class="container d-flex align-items-center justify-content-between h-100 pl-3 pr-3 pl-md-4 pr-md-4"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>计组实验1：汇编语言与监控程序</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper" class="d-flex justify-content-center"><div id="main" class="container pl-xl-4 pr-xl-4"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-9 pr-xl-4"><div class="post pl-1 pr-1 pl-md-2 pr-md-2"><h1 data-toc-skip>计组实验1：汇编语言与监控程序</h1><div class="post-meta text-muted"> <span> Posted <em class="" data-ts="1663423447" data-df="ll" data-toggle="tooltip" data-placement="bottom"> Sep 17, 2022 </em> </span> <span> Updated <em class="" data-ts="1665230513" data-df="ll" data-toggle="tooltip" data-placement="bottom"> Oct 8, 2022 </em> </span><div class="d-flex justify-content-between"> <span> By <em> <a href="https://github.com/hanna0911">Hanna Wang</a> </em> </span><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="8619 words"> <em>47 min</em> read</span></div></div></div><div class="post-content"><h2 id="实验报告"><span class="mr-2">实验报告</span><a href="#实验报告" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="实验1risc-v监控程序与term命令"><span class="mr-2">实验1：RISC-V监控程序与Term命令</span><a href="#实验1risc-v监控程序与term命令" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>在模拟器中运行 RISC-V 监控程序的基本步骤如下：</p><ol><li><p>启动监控程序</p><p><img data-src="/assets/Screen Shot 2022-09-14 at 2.07.46 PM.png" alt="Screen Shot 2022-09-14 at 2.07.46 PM" data-proofer-ignore></p><li><p>通过终端连接监控程序</p><p><img data-src="/assets/Screen Shot 2022-09-14 at 2.08.16 PM.png" alt="Screen Shot 2022-09-14 at 2.08.16 PM" style="zoom:33%;" data-proofer-ignore></p></ol><p>Term 中几个命令的使用方法（以下对每个命令的介绍均来自<code class="language-plaintext highlighter-rouge">supervisor-rv/</code>文件夹中的<code class="language-plaintext highlighter-rouge">README.md</code>文件）：</p><ol><li><p><code class="language-plaintext highlighter-rouge">R</code>：按照 x1 至 x31 的顺序返回用户程序寄存器值。</p><p><img data-src="/assets/Screen Shot 2022-09-14 at 2.11.48 PM.png" alt="Screen Shot 2022-09-14 at 2.11.48 PM" style="zoom: 33%;" data-proofer-ignore></p><li><p><code class="language-plaintext highlighter-rouge">D</code>：显示从指定地址开始的一段内存区域中的数据。</p><p><img data-src="/assets/Screen Shot 2022-09-14 at 2.12.15 PM.png" alt="Screen Shot 2022-09-14 at 2.12.15 PM" style="zoom:33%;" data-proofer-ignore></p><li><p><code class="language-plaintext highlighter-rouge">A</code>：用户输入汇编指令，并放置到指定地址上</p><p><img data-src="/assets/Screen Shot 2022-09-14 at 2.14.14 PM.png" alt="Screen Shot 2022-09-14 at 2.14.14 PM" style="zoom:33%;" data-proofer-ignore></p><li><p><code class="language-plaintext highlighter-rouge">F</code>：从文件读入汇编指令并放置到指定地址上，格式与 A 命令相同。</p><p><img data-src="/assets/Screen Shot 2022-09-14 at 2.16.40 PM.png" alt="Screen Shot 2022-09-14 at 2.16.40 PM" style="zoom:33%;" data-proofer-ignore></p><li><p><code class="language-plaintext highlighter-rouge">U</code>：从指定地址读取一定长度的数据，并显示反汇编结果。</p><p><img data-src="/assets/Screen Shot 2022-09-14 at 2.17.30 PM.png" alt="Screen Shot 2022-09-14 at 2.17.30 PM" style="zoom: 33%;" data-proofer-ignore></p><li><p><code class="language-plaintext highlighter-rouge">G</code>：执行指定地址的用户程序。</p><p><img data-src="/assets/Screen Shot 2022-09-14 at 2.17.54 PM.png" alt="Screen Shot 2022-09-14 at 2.17.54 PM" style="zoom:33%;" data-proofer-ignore></p><li><p><code class="language-plaintext highlighter-rouge">T</code>：查看页表内容，仅在启用页表时有效。</p><p><img data-src="/assets/Screen Shot 2022-09-14 at 2.18.30 PM.png" alt="Screen Shot 2022-09-14 at 2.18.30 PM" style="zoom:33%;" data-proofer-ignore></p><p>加上flag<code class="language-plaintext highlighter-rouge">EN_PAGING=y</code>来启动监控程序，以启用页表（以下是部分页表内容截图）：</p><p><img data-src="/assets/Screen Shot 2022-09-15 at 10.19.30 AM.png" alt="Screen Shot 2022-09-15 at 10.19.30 AM" style="zoom:33%;" data-proofer-ignore></p><p><img data-src="/assets/Screen Shot 2022-09-15 at 10.18.38 AM.png" alt="Screen Shot 2022-09-15 at 10.18.38 AM" style="zoom:33%;" data-proofer-ignore></p><li><p><code class="language-plaintext highlighter-rouge">Q</code>：退出 Term。</p><p><img data-src="/assets/Screen Shot 2022-09-14 at 2.19.51 PM.png" alt="Screen Shot 2022-09-14 at 2.19.51 PM" style="zoom:33%;" data-proofer-ignore></p></ol><h3 id="实验2求前10个fibonacci数"><span class="mr-2">实验2：求前10个Fibonacci数</span><a href="#实验2求前10个fibonacci数" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>我的代码参考了<code class="language-plaintext highlighter-rouge">asmcode/</code>文件夹中<code class="language-plaintext highlighter-rouge">sum.s</code>与<code class="language-plaintext highlighter-rouge">fib-mem.s</code>代码。其中<code class="language-plaintext highlighter-rouge">sum.s</code>中采用循环的方式计算了$1 + 2 + … + 10$，在我的代码中也参考了这一循环<code class="language-plaintext highlighter-rouge">loop</code>的书写方式，通过一个计数器<code class="language-plaintext highlighter-rouge">t3</code>来控制是否完成了<code class="language-plaintext highlighter-rouge">t4 = 10</code>次的计算循环（事实上只需要进行8次循环即可，因为前2项Fib数是既定已给出的，无需计算）。<code class="language-plaintext highlighter-rouge">fib-mem.s</code>中比较关键的则是Fib数递推的步骤：根据递推式计算下一个Fib数<code class="language-plaintext highlighter-rouge">add t2, t0, t1 # t2 = t0+t1</code>，以及为下一轮递推做准备<code class="language-plaintext highlighter-rouge">ori t0, t1, 0x0 # t0 = t1</code>, <code class="language-plaintext highlighter-rouge">ori t1, t2, 0x0 # t1 = t2</code>，在我的代码中也参考了这一书写规范来进行Fib数的递推计算。</p><p>代码的总体思路分为以下几步：</p><ol><li>初始化加数（第一个Fib数<code class="language-plaintext highlighter-rouge">t0</code>，第二个Fib数<code class="language-plaintext highlighter-rouge">t1</code>），并设置好计数器相关变量（已计算次数<code class="language-plaintext highlighter-rouge">t3</code>、总共计算次数<code class="language-plaintext highlighter-rouge">t4</code>）、待写入地址<code class="language-plaintext highlighter-rouge">t5</code>；<li>将前2个已知Fib数写入当前地址，并更新下一待写入地址；<li>通过循环，以计算Fib递推式计算下一个Fib数<code class="language-plaintext highlighter-rouge">t2 = t0 + t1</code>，并在进入下一轮循环之前更新计算次数<code class="language-plaintext highlighter-rouge">t3</code>、待写入地址<code class="language-plaintext highlighter-rouge">t5</code>、新一轮递推的加数<code class="language-plaintext highlighter-rouge">t0</code>,<code class="language-plaintext highlighter-rouge"> t1</code>，其中循环的终止条件为<code class="language-plaintext highlighter-rouge">t3 == t4</code>（即完成了<code class="language-plaintext highlighter-rouge">t4</code>次计算）；<li>达到循环的终止条件（或不再满足循环的执行条件<code class="language-plaintext highlighter-rouge">t3 != t4</code>），返回，程序终止。</ol><div class="language-bash highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre><td class="rouge-code"><pre>    .global _start
    .text

_start:

    li t0, 0x1   <span class="c"># t0 = 1，加数（第1个Fib数）</span>
    li t1, 0x1   <span class="c"># t1 = 1，加数（第2个Fib数）</span>
    li t3, 0x2   <span class="c"># 已计算次数，用于计数（前2项已给出）</span>
    li t4, 0xA   <span class="c"># t4 = 10，一共需计算前10个Fib数</span>
    li t5, 0x80400000  <span class="c"># 待写入的地址</span>

    sw  t0, 0x0<span class="o">(</span>t5<span class="o">)</span>  <span class="c"># 将第1个Fib数写入地址</span>
    sw  t1, 0x4<span class="o">(</span>t5<span class="o">)</span>  <span class="c"># 将第2个Fib数写入地址</span>
    addi t5, t5, 0x8  <span class="c"># 待写入地址自增</span>

loop:

    add t2, t0, t1   <span class="c"># t2 = t0 + t1，Fib数递推式</span>
    addi t3, t3, 0x1  <span class="c"># t3++，已计算次数自增</span>
    sw  t2, 0x0<span class="o">(</span>t5<span class="o">)</span>  <span class="c"># 将第t3个Fib数写入地址</span>
    addi t5, t5, 0x4  <span class="c"># 待写入地址自增</span>

    ori t0, t1, 0x0  <span class="c"># t0 = t1，为新一轮Fib数递推计算做准备</span>
    ori t1, t2, 0x0  <span class="c"># t1 = t2，同上</span>
    bne t3, t4, loop <span class="c"># 若没算完10个Fib数（t3 != t4），则通过loop继续计算</span>
    nop
    jr ra            <span class="c"># 否则（t3 == t4）返回，程序终止</span>
    nop
</pre></table></code></div></div><p>在<code class="language-plaintext highlighter-rouge">supervisor-rv/kernel/</code>目录下执行<code class="language-plaintext highlighter-rouge">make sim</code>启动监控程序，并在<code class="language-plaintext highlighter-rouge">supervisor-rv/term/</code>目录下执行<code class="language-plaintext highlighter-rouge">python3 term.py -t 127.0.0.1:6666</code>通过终端连接监控程序，并用<code class="language-plaintext highlighter-rouge">&gt;&gt; F</code>命令在监控程序中运行以上代码；通过<code class="language-plaintext highlighter-rouge">&gt;&gt; D</code>命令查看内存地址<code class="language-plaintext highlighter-rouge">0x80400000~0x80400024</code>，结果如下：</p><p><img data-src="/assets/Screen Shot 2022-09-14 at 11.32.32 AM.png" alt="Screen Shot 2022-09-14 at 11.32.32 AM" style="zoom: 50%;" data-proofer-ignore></p><p>验证了存入起始地址为<code class="language-plaintext highlighter-rouge">0x80400000</code>的10个字中的数（16进制），与前10个Fibonacci数$1, 1, 2, 3, 5, 8, 13, 21, 34, 55$（十进制）一一对应，结果正确。</p><h3 id="实验3输出ascii可见字符"><span class="mr-2">实验3：输出ASCII可见字符</span><a href="#实验3输出ascii可见字符" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>我的代码参考了实验说明文档中提供的<code class="language-plaintext highlighter-rouge">WRITE_SERIAL</code>、<code class="language-plaintext highlighter-rouge">.TESTW</code>、<code class="language-plaintext highlighter-rouge">.WSERIAL</code>函数，以实现从终端输出字符。至于输出由<code class="language-plaintext highlighter-rouge">0x21</code>~<code class="language-plaintext highlighter-rouge">0x7E</code>共94个ASCII可见字符，采用循环的方式（94次循环）来进行输出，其中<code class="language-plaintext highlighter-rouge">a0</code>寄存器所存储的既是输出的对象（ASCII可见字符的十六进制编码）、又是计数器（由<code class="language-plaintext highlighter-rouge">0x21</code>开始计数到<code class="language-plaintext highlighter-rouge">0x7E</code>）。</p><p>代码的总体思路分为以下几步：</p><ol><li>初始化循环开始字符<code class="language-plaintext highlighter-rouge">a0</code>、结束字符<code class="language-plaintext highlighter-rouge">t2</code>，注意因为执行循环的边界条件判断为“不等”（<code class="language-plaintext highlighter-rouge">bne a0, t2, WRITE_SERIAL # a0 != t2 </code> ）而非“小于等于”（<code class="language-plaintext highlighter-rouge">a0 &lt;= t2</code>），因此结束字符<code class="language-plaintext highlighter-rouge">t2</code>需要额外加一；<li>通过循环，向终端（<code class="language-plaintext highlighter-rouge">0x10000000</code>）输出<code class="language-plaintext highlighter-rouge">a0</code>寄存器中的最低字节，并在进入下一轮循环前更新<code class="language-plaintext highlighter-rouge">a0</code>的值（<code class="language-plaintext highlighter-rouge">a0++</code>，切换到下一顺位ASCII可见字符），其中循环的终止条件为<code class="language-plaintext highlighter-rouge">a0 == t2</code>（即完成了由<code class="language-plaintext highlighter-rouge">0x21</code>~<code class="language-plaintext highlighter-rouge">0x7E</code>所有ASCII可见字符的输出）；<li>达到循环的终止条件（或不再满足循环的执行条件<code class="language-plaintext highlighter-rouge">a0 != t2</code>），返回，程序终止。</ol><div class="language-bash highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre><td class="rouge-code"><pre>.section .text
.globl _start

_start:
    li  a0, 0x21      <span class="c"># 循环开始字符</span>
    li  t2, 0x7E      <span class="c"># 循环结束字符</span>
    addi t2, t2, 0x1  <span class="c"># .WSERIAL处bne边界条件</span>

WRITE_SERIAL:
    <span class="c"># 串口地址是 0x10000000</span>
    li t0, 0x10000000

    <span class="c"># 轮询串口状态（0x10000005）</span>

.TESTW:
    lb t1, 5<span class="o">(</span>t0<span class="o">)</span>
    <span class="c"># 判断是否可写</span>
    andi t1, t1, 0x20
    beq t1, zero, .TESTW

.WSERIAL:
    <span class="c"># 向终端（0x10000000）输出 a0 寄存器中的最低字节</span>
    sb a0, 0<span class="o">(</span>t0<span class="o">)</span>

    addi a0, a0, 0x1          <span class="c"># a0++，切换到下一字符以输出</span>
    bne a0, t2, WRITE_SERIAL  <span class="c"># 若未达到边界条件（a0 != t2）则继续输出ascii字符</span>
    nop
    jr ra                     <span class="c"># 否则（a0 == t2）返回，终止程序</span>
    nop
</pre></table></code></div></div><p>同样启动监控程序，并通过终端连接监控程序，在监控程序中运行以上代码，得到结果：</p><p><img data-src="/assets/Screen Shot 2022-09-15 at 2.08.50 PM.png" alt="Screen Shot 2022-09-15 at 2.08.50 PM" data-proofer-ignore></p><p>成功向终端输出了ASCII 可见字符：</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>!"#$%&amp;'()*+,-./0123456789:;&lt;=&gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~
</pre></table></code></div></div><h3 id="实验4求第60个fibonacci数"><span class="mr-2">实验4：求第60个Fibonacci数</span><a href="#实验4求第60个fibonacci数" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>与实验2基本一致，但由于第60个Fibonacci数已经超过了32位整型，因此需要在实验2的基础上作出一些修改，主要区别如下：</p><ol><li>原先存储Fib数的3个32位寄存器<code class="language-plaintext highlighter-rouge">t0</code>、<code class="language-plaintext highlighter-rouge">t1</code>、<code class="language-plaintext highlighter-rouge">t2</code>，改由6个32位寄存器存储，其中每个64位的整数由2个32位寄存器储存，即<code class="language-plaintext highlighter-rouge">{a3, a2}</code>储存第一个Fib数、<code class="language-plaintext highlighter-rouge">{a5, a4}</code>储存第二个Fib数、<code class="language-plaintext highlighter-rouge">{a1, a0}</code>用来储存由Fib递推式计算得到的下一个Fib数（高位为<code class="language-plaintext highlighter-rouge">a3</code>、<code class="language-plaintext highlighter-rouge">a5</code>、<code class="language-plaintext highlighter-rouge">a1</code>，低位为<code class="language-plaintext highlighter-rouge">a2</code>、<code class="language-plaintext highlighter-rouge">a4</code>、<code class="language-plaintext highlighter-rouge">a0</code>）；<li>计数器相关变量已计算次数<code class="language-plaintext highlighter-rouge">t3</code>保持一致，而总共计算次数<code class="language-plaintext highlighter-rouge">t4</code>由10（<code class="language-plaintext highlighter-rouge">0xA</code>）改为60（<code class="language-plaintext highlighter-rouge">0x3C</code>）；<li>根据Fib递推式进行的加法运算，由原来的32位整型加法改为64位整型加法，此处参考了实验说明文档中提供的大位宽数据加法的实现方法；<li>为新一轮Fib数递推计算做准备，赋值时注意要把两个Fib加数的高位、低位寄存器都赋值（因此由原本的两个语句变为四个语句，每个加数各有两个待更新的寄存器需要被赋值）；<li>只需将第60个Fib数写入制定内存地址即可，因此不再需要每次循环都写入一次地址，而只需要在退出循环之后，执行一次第60个Fib数<code class="language-plaintext highlighter-rouge">{a1, a0}</code>的写入即可（注意低位<code class="language-plaintext highlighter-rouge">a0</code>写入<code class="language-plaintext highlighter-rouge">0x80400000</code>、高位<code class="language-plaintext highlighter-rouge">a1</code>写入<code class="language-plaintext highlighter-rouge">0x80400004</code>）。</ol><div class="language-bash highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
</pre><td class="rouge-code"><pre>    .global _start
    .text
    
_start:

    li a1, 0x0   <span class="c"># {a1, a0} = {0, 0}，初始化Fib数和</span>
    li a0, 0x0
    li a3, 0x0   <span class="c"># {a3, a2} = {0, 1}，初始化Fib数加数（第1个Fib数为1）</span>
    li a2, 0x1
    li a5, 0x0   <span class="c"># {a5, a4} = {0, 1}，初始化Fib数加数（第2个Fib数为1）</span>
    li a4, 0x1

    li t3, 0x2   <span class="c"># 已计算次数，用于计数（前2项已给出）</span>
    li t4, 0x3C  <span class="c"># t4 = 60，需计算到第60个Fib数</span>
    li t5, 0x80400000  <span class="c"># 待写入的地址</span>

loop:
    <span class="c"># {a3, a2} 即把低位保存在 a2，高位保存在 a3 的 64 位整数</span>
    <span class="c"># {a3, a2} + {a5, a4} = {a1, a0}</span>
    add a0, a2, a4
    sltu a2, a0, a2
    add a1, a3, a5
    add a1, a2, a1

    addi t3, t3, 0x1  <span class="c"># t3++，已计算次数自增</span>

    ori a3, a5, 0x0   <span class="c"># {a3, a2} = {a5, a4}，为新一轮Fib数递推计算做准备</span>
    ori a2, a4, 0x0
    ori a5, a1, 0x0   <span class="c"># {a5, a4} = {a1, a0}，同上</span>
    ori a4, a0, 0x0

    bne t3, t4, loop  <span class="c"># 若没算到第60个Fib数（t3 != t4），则通过loop继续计算</span>
    nop

    sw a0, 0x0<span class="o">(</span>t5<span class="o">)</span>    <span class="c"># 否则（t3 == t4）将第60个Fib数{a1, a0}写入地址</span>
    sw a1, 0x4<span class="o">(</span>t5<span class="o">)</span>

    jr ra             <span class="c"># 返回，程序终止</span>
    nop
</pre></table></code></div></div><p>同样启动监控程序，并通过终端连接监控程序，在监控程序中运行以上代码（方法与实验2、3均一致，此处省略），得到结果：</p><p><img data-src="/assets/Screen Shot 2022-09-14 at 1.03.52 PM.png" alt="Screen Shot 2022-09-14 at 1.03.52 PM" style="zoom: 50%;" data-proofer-ignore></p><p>存入内存的结果<code class="language-plaintext highlighter-rouge">0x1686c8312d0</code>（十六进制）与第60个Fib数1548008755920（十进制）相同，结果正确。</p><h2 id="代码分析报告"><span class="mr-2">代码分析报告</span><a href="#代码分析报告" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>虽然在<code class="language-plaintext highlighter-rouge">supervisor-rv/README.md</code>文件中的“介绍”章节中写到“<strong>监控程序</strong>分为两个部分，<strong>Kernel</strong>和<strong>Term</strong>”，但鉴于实验说明文档中的要求是“撰写<strong>监控程序</strong>以及<strong>终端程序</strong>的代码分析报告”，以下均以实验说明文档中的说法为准，即<strong>监控程序</strong>代表<strong>Kernel</strong>、<strong>终端程序</strong>代表<strong>Term</strong>，而<code class="language-plaintext highlighter-rouge">README.md</code>文档中的“监控程序Supervisor”本质为一个简化的“<strong>操作系统</strong>”（即操作系统Supervisor分为监控程序Kernel和终端程序Term两个部分）。</p><p>在本次实验中，监控程序Kernel被运行在模拟环境QEMU中（QEMU模拟了RISC-V指令与系统，在后续实验中模拟环境QEMU将被物理实验平台替代），而我们需要通过终端程序Term与模拟环境QEMU中的监控程序Kernel进行交互，具体交互流程将在后续<a href="#1">交互流程</a>一节中阐释。以下将先分别给出监控程序Kernel与终端程序Term的代码分析。</p><h3 id="监控程序kernel"><span class="mr-2">监控程序Kernel</span><a href="#监控程序kernel" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>监控程序Kernel的代码在<code class="language-plaintext highlighter-rouge">supervisor-rv/kernal/</code>文件夹中：</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre><td class="rouge-code"><pre>.
├── Makefile（编译规则）
├── debug（调试指令）
├── include（头文件）
│   ├── common.h（基本信息如使用32位或64位架构使用的访存指令与地址位数、用户栈初始化、各信号相关常量等）
│   ├── exception.h（异常相关的常量）
│   └── serial.h（串口相关的常量）
├── kern（监控程序Kernel核心代码！！！）
│   ├── evec.S（监控程序入口点）
│   ├── init.S（监控程序初始化）
│   ├── kernel32.ld（32位RISC-V的链接文件）
│   ├── kernel64.ld（64位RISV-V的链接文件）
│   ├── shell.S（监控程序的交互功能实现）
│   ├── test.S（监控程序的性能测试程序）
│   ├── trap.S（监控程序中涉及中断相关代码）
│   └── utils.S（通过串口进行读、写数据相关代码）
├── kernel.asm（make编译Kernel程序后生成的文件）
├── kernel.bin（make编译Kernel程序后生成的文件）
├── kernel.elf（make编译Kernel程序后生成的文件）
└── obj/（内含make编译Kernel程序后生成的文件）
</pre></table></code></div></div><p>核心代码均在<code class="language-plaintext highlighter-rouge">kern/</code>文件夹中，其中涉及到本次实验基础版本Kernel的文件为 <code class="language-plaintext highlighter-rouge">evec.S</code> 、 <code class="language-plaintext highlighter-rouge">init.S</code> 、 <code class="language-plaintext highlighter-rouge">shell.S</code> 、 <code class="language-plaintext highlighter-rouge">utils.S</code> 这4个文件。程序的结构为：</p><pre><code class="language-mermaid">graph TD

		subgraph evec.S
				subgraph INITLOCATE
						A[Kernel入口, 跳转到init.S: START]
				end
		end
		A --&gt; C
		subgraph init.S
				subgraph START
            C[清空BSS段, 设置内核栈+用户栈+用户态程序sp和fp寄存器] --&gt; D[配置串口等]
            D --&gt; D1[配置中断帧]
				end
				subgraph WELCOME
						D1 --&gt; D2[装入启动信息并打印]
						D3[跳转到shell.S: SHELL, 开始交互]
						
				end
		end
		
		D3 --&gt; E
		
		subgraph utils.S
				subgraph WRITE_SERIAL_STRING
						D2 --&gt; H[写字符串: 将a0地址开始处的字符串写入串口]
						H --&gt; H1[调用串口写函数]	
						G[打印循环至 0 结束符]
				end
				
				subgraph WRITE_SERIAL
						H1 --&gt; H2[写串口: 将a0的低八位写入串口]
						H2 --&gt; H3[检测验证: 截取并查看串口状态的写状态位]
						H3 --&gt;|非零可写, 进入写|H3_1[写入寄存器a0中的值]
						H3 --&gt;|为零不可写, 忙等待|H3
						H3_1 --&gt; G
						G --&gt; D3
				end
				
								
				subgraph READ_SERIAL
						F[读串口: 将读到的数据写入a0低八位]
						F --&gt; F1[检测验证: 截取并查看串口状态的读状态位]
						F1 --&gt;|非零可读, 进入读|F1_1[将串口中的值读取到寄存器a0]
						F1 --&gt;|为零不可读, 忙等待|F1
				end
		end
		
				
		subgraph shell.S
				subgraph SHELL
						E[调用串口读函数, 读取操作符] --&gt; F
						F1_1 --&gt; I[根据操作符进行不同的操作]
						
						I --&gt;|'R'|OP_R
						I --&gt;|'D'|OP_D
						I --&gt;|'A'|OP_A
						I --&gt;|'G'|OP_G
						I --&gt;|'T'|OP_T
						I --&gt;|其他, 主要指'W'|OP_OTHER
						
						subgraph .OP_R
								OP_R[打印用户空间寄存器]
						end
						
						subgraph .OP_D
								OP_D[打印内存num个字节]
						end
						
						subgraph .OP_A
								OP_A[写入内存num字节, num为4的倍数]
						end
						
						subgraph .OP_G
								OP_G[跳转到用户程序执行]
						end
						
						subgraph .OP_T
								OP_T[打印页表] 
						end
						
						subgraph OTHER[错误反馈]
								OP_OTHER[把XLEN写给term] 
						end
						
						OP_R --&gt; E
						OP_D --&gt; E
						OP_A --&gt; E
						OP_G --&gt; E
						OP_T --&gt; E
						OP_OTHER --&gt; E
						
				end
		end		
</code></pre><p>由于<code class="language-plaintext highlighter-rouge">shell.S</code>中的具体操作（<code class="language-plaintext highlighter-rouge">R</code>、<code class="language-plaintext highlighter-rouge">D</code>、<code class="language-plaintext highlighter-rouge">A</code>、<code class="language-plaintext highlighter-rouge">G</code>、<code class="language-plaintext highlighter-rouge">T</code>）繁多，在上图中不一一分析具体实现方法，只取比较核心的<code class="language-plaintext highlighter-rouge">G</code>运行用户代码操作做详细分析，其代码结构如下（所有的循环<code class="language-plaintext highlighter-rouge">i = 0, 1, 2, 3</code>均是为了报告中书写方便，在实际代码中采用了直接书写四次代码实现）：</p><pre><code class="language-mermaid">graph TD
		subgraph shell.S
				subgraph .OP_G
						OP_G1[获取用户程序地址]
						OP_G2[从a0保存用户地址到s10]
						OP_G2 --&gt; OP_G3[写开始计时信号SIG_TIMERSET到串口, 通知Term开始运行]
						OP_G4[定位用户空间寄存器备份地址] --&gt; OP_G5[恢复用户程序调用前的寄存器数据]
						OP_G5 --&gt; OP_G6[重新获得当前监控程序栈顶指针]
						OP_G6 --&gt; OP_G7[写停止计时信号SIG_TIMETOKEN到串口, 通知Term结束计时, 调用WRITE_SERIAL过程与前述写SIG_TIMERSET一致, 此处省略]
				end
		end
		
		OP_G1 --&gt; READ1
		OP_G3 --&gt; WRITE
		
		subgraph utils.S
				subgraph READ_SERIAL_XLEN
						READ1[调用READ_SERIAL_WORD函数]
				end
				
				READ1 --&gt; READ2
				
				subgraph READ_SERIAL_WORD
						READ2[保存ra, s0-s3]
						READ4[结果存入si, i++]
						READ5[截取s0-s3的低8位] --&gt;|第i次, i=0,1,2,3|READ6[存si的高8位到a0中, 再左移8位, i++]
						READ6 --&gt;|i&lt;4|READ6
						READ6 --&gt;|i&gt;=4|READ7[通过ra保存的返回地址返回]
				end
				
				READ2 --&gt;|调用第i次, i=0,1,2,3|READ3
				
				subgraph READ_SERIAL
						READ3[读串口获得8位数据]
				end
				
				READ3 --&gt; READ4
				READ4 --&gt;|i&lt;4|READ3
				READ4 --&gt;|i&gt;=4|READ5
				READ7 --&gt; OP_G2
				
				subgraph WRITE_SERIAL
						WRITE[检测验证+写串口, 同前述过程, 此处省略]
				end
				
				WRITE --&gt; OP_G4
				
		end
		
		
</code></pre><h3 id="终端程序term"><span class="mr-2">终端程序Term</span><a href="#终端程序term" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>终端程序的代码在<code class="language-plaintext highlighter-rouge">supervisor-rv/term/term.py</code>文件中，程序的结构为：</p><pre><code class="language-mermaid">graph TD
		subgraph main
				main2[设置命令行参数] 
				main3[初始化失败, 程序终止]
				main4[初始化成功, 进入Main函数]
		end
		
		main2 --&gt;|检测tcp|TCP0.5
		main4 --&gt; Main1
		
		subgraph InitializeTCP
				TCP0[创建tcp_wrapper类的服务器ser]--&gt;TCP0.5[连接kernel, 设置inp, outp]
		end
		
		TCP0.5 --&gt; TCP1
		
		subgraph tcp_wrapper
				subgraph connect
						TCP1[通过python的stdlib中的socket模块connect函数, 连接TCP服务器kernel的host+port]
				end
				
				subgraph read
						TCP_read[通过stdlib中的socket模块recv函数, 8位8位读取串口数据]
				end
				
				subgraph write
						TCP_write[通过stdlib中的socket模块send函数, 8位8位写入串口数据]
				end
		end
		
		TCP1 --&gt;|连接成功|main3
    TCP1 --&gt;|连接失败|main4
		
		Main0 --&gt; TCP_read
		TCP_read --&gt; Main1
		subgraph Main
				Main0[通过inp.read读取串口, 获得kernel发来的欢迎信息与xlen信息]
				Main1[输出, 并进入MainLoop函数]
		end
		
		Main1 --&gt; ML1
		subgraph Mainloop
				ML1[根据用户在命令行中的指令cmd, 执行不同操作]
				
        ML1--&gt;|'A'|A
        ML1--&gt;|'F'|F
        ML1--&gt;|'R'|R
        ML1--&gt;|'D'|D
        ML1--&gt;|'U'|U
        ML1--&gt;|'G'|G
        ML1--&gt;|'T'|T
        ML1--&gt;|'Q'|Q
        subgraph run_A
            A[用户输入汇编指令, 并放置到指定地址上]
        end

        subgraph run_F
            F[从文件读入汇编指令并放置到指定地址上]
        end

        subgraph run_R
            R[返回用户程序寄存器值]
        end

        subgraph run_D
            D[显示从指定地址开始的一段内存区域中的数据]
        end

        subgraph run_U
            U[从指定地址读取一定长度的数据, 并显示反汇编结果]
        end

        subgraph run_G
            G[执行指定地址的用户程序]
        end

        subgraph run_T
            T[查看页表内容, 仅在启用页表时有效]
        end

        Q[退出Term]
        
        A--&gt;ML2
        F--&gt;ML2
        R--&gt;ML2
        D--&gt;ML2
        U--&gt;ML2
        G--&gt;ML2
        T--&gt;ML2
        
        ML2[通过outp.write写入串口, 通知kernel执行该命令]--&gt;TCP_write
        TCP_write --&gt; ML1
		end
</code></pre><h3 id="交互流程"><span class="mr-2">交互流程<a id="1"><span class="mr-2"></a></span><a href="#交互流程" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Kernel和Term通过串口进行交互，即用户在Term中输入的命令、代码在经过 Term 处理后通过串口传输给 Kernel，而Kernel需要输出的信息也会通过串口传输到Term并展示给用户。在这里是使用QEMU模拟串口，其地址如<code class="language-plaintext highlighter-rouge">README.md</code>文件所描述的：</p><blockquote><p>设置了一个内存以外的地址区域，用于串口收发。串口控制器按照 <a href="https://www.lammertbies.nl/comm/info/serial-uart">16550 UART 的寄存器</a> 的子集实现，访问的代码位于 <code class="language-plaintext highlighter-rouge">kern/utils.S</code> ，其部分数据格式为：</p><div class="table-wrapper"><table><thead><tr><th>地址<th>位<th>说明<tbody><tr><td><code class="language-plaintext highlighter-rouge">COM1</code> = 0x10000000<td>[7:0]<td>串口数据，读、写地址分别表示串口接收、发送一个字节<tr><td><code class="language-plaintext highlighter-rouge">COM1 + COM_LSR_OFFSET</code> = 0x10000005<td>[5]<td>只读，为1时表示串口空闲，可发送数据<tr><td><code class="language-plaintext highlighter-rouge">COM1 + COM_LSR_OFFSET</code> = 0x10000005<td>[0]<td>只读，为1时表示串口收到数据</table></div></blockquote><p>意思是不论是Kernel要读写数据（从/给Term读/写），还是Term要读写数据（从/给Kernel读/写），二者均需要在判断<code class="language-plaintext highlighter-rouge">0x10000005</code>地址处的相关检验位（可写位是第<code class="language-plaintext highlighter-rouge">5</code>位，可读位是第<code class="language-plaintext highlighter-rouge">0</code>位）为1时，从<code class="language-plaintext highlighter-rouge">0x10000000</code>读/写8位的数据。一个重要的例子是，在前面针对监控程序Kernel的代码分析中，分析过的Term向Kernel发送用户代码的32位地址数据时（Term写、Kernel读），二者均需在判断可写/读时每次仅进行8位的数据交互，共4次，Kernel读到这4个8位的数据还需通过依次放入目标寄存器再左移的方法复原32位数据，实现完整的32位地址数据交互。</p><p>在Kernel中交互主要的代码块在<code class="language-plaintext highlighter-rouge">utils.S</code>中，包含向串口写入数据的 <code class="language-plaintext highlighter-rouge">WRITE_SERIAL</code> 、 <code class="language-plaintext highlighter-rouge">WRITE_SERIAL_WORD</code> 、 <code class="language-plaintext highlighter-rouge">WRITE_SERIAL_XLEN</code> 、 <code class="language-plaintext highlighter-rouge">WRITE_SERIAL_STRING</code> 函数，以及从串口读入数据的 <code class="language-plaintext highlighter-rouge">READ_SERIAL</code> 、 <code class="language-plaintext highlighter-rouge">READ_SERIAL_WORD</code> 、 <code class="language-plaintext highlighter-rouge">READ_SERIAL_XLEN</code> 函数。其中 <code class="language-plaintext highlighter-rouge">WRITE_SERIAL_WORD</code> 、 <code class="language-plaintext highlighter-rouge">WRITE_SERIAL_XLEN</code> 、 <code class="language-plaintext highlighter-rouge">WRITE_SERIAL_STRING</code> 均是基于 <code class="language-plaintext highlighter-rouge">WRITE_SERIAL</code> 函数（内部根据写出的数据大小，选择调用对应次数的 <code class="language-plaintext highlighter-rouge">WRITE_SERIAL</code> 函数），<code class="language-plaintext highlighter-rouge">READ_SERIAL_WORD</code> 、 <code class="language-plaintext highlighter-rouge">READ_SERIAL_XLEN</code> 均是基于 <code class="language-plaintext highlighter-rouge">READ_SERIAL</code> 函数（内部根据读入的数据大小，选择调用对应次数的 <code class="language-plaintext highlighter-rouge">WRITE_SERIAL</code> 函数）。对于串口地址、串口检验地址等常量均定义在<code class="language-plaintext highlighter-rouge">include/serial.h</code>中。</p><p>而 <code class="language-plaintext highlighter-rouge">WRITE_SERIAL</code> 和 <code class="language-plaintext highlighter-rouge">READ_SERIAL</code> 的核心内容，总结如下：</p><ol><li>判断检验位：将判断地址<code class="language-plaintext highlighter-rouge">0x10000005</code>处的数据通过<code class="language-plaintext highlighter-rouge">lb</code>指令读到<code class="language-plaintext highlighter-rouge">t1</code>寄存器中，再通过<code class="language-plaintext highlighter-rouge">andi</code>运算（<code class="language-plaintext highlighter-rouge">WRITE_SERIAL</code>中为<code class="language-plaintext highlighter-rouge">t1 = t1 &amp; COM_LSR_THRE = t1 &amp; 0x20</code> 即 <code class="language-plaintext highlighter-rouge">t1 = t1 &amp; 0b00100000</code>截取第<code class="language-plaintext highlighter-rouge">5</code>位检验位是否可写；<code class="language-plaintext highlighter-rouge">READ_SERIAL</code>中为<code class="language-plaintext highlighter-rouge">t1 = t1 &amp; COM_LSR_DR = t1 &amp; 0x01</code>即 <code class="language-plaintext highlighter-rouge">t1 = t1 &amp; 0b00000001</code>截取第<code class="language-plaintext highlighter-rouge">1</code>为检验位是否可读）截取检验位并判断是否可写/可读（可写/可读计算为1，不可写/不可读为0）；<li>根据检验位的合法性决定下一步执行动作（条件跳转<code class="language-plaintext highlighter-rouge">bne</code>）：若检验位不合法（为0）则通过循环判断检验位代码的方法实现“忙等待”，不断“轮询串口状态”直到合法（为1）；若检验位合法（为1）则直接顺序执行后面的代码（真正执行读/写到串口的代码）；<li>读/写：通过<code class="language-plaintext highlighter-rouge">sb</code>（<code class="language-plaintext highlighter-rouge">WRITE_SERIAL</code>，写）、<code class="language-plaintext highlighter-rouge">lb</code>（<code class="language-plaintext highlighter-rouge">READ_SERIAL</code>，读）向/从串口地址<code class="language-plaintext highlighter-rouge">0x10000000</code>读/写数据。</ol><p>这种通过 <code class="language-plaintext highlighter-rouge">sb</code>、<code class="language-plaintext highlighter-rouge">lb</code> 等内存访问指令来实现的对于串口的访问，实际是访问的外设寄存器，这种访问方式叫做MMIO（内存映射 IO）。</p><p>在Term中交互主要的代码块在<code class="language-plaintext highlighter-rouge">term.py</code>文件里<code class="language-plaintext highlighter-rouge">class tcp_wrapper</code>中定义的<code class="language-plaintext highlighter-rouge">write</code>函数与<code class="language-plaintext highlighter-rouge">read</code>函数，函数实现是基于Python的stdlib库中<code class="language-plaintext highlighter-rouge">socket</code>模块的<code class="language-plaintext highlighter-rouge">send</code>、<code class="language-plaintext highlighter-rouge">recv</code>函数。虽然不确定<code class="language-plaintext highlighter-rouge">socket</code>模块的<code class="language-plaintext highlighter-rouge">send</code>、<code class="language-plaintext highlighter-rouge">recv</code>函数具体是如何实现的，但根据Kernel在<code class="language-plaintext highlighter-rouge">utils.S</code>中的读 <code class="language-plaintext highlighter-rouge">READ_SERIAL</code> /写 <code class="language-plaintext highlighter-rouge">WRITE_SERIAL</code> 函数每次只读取/写入<code class="language-plaintext highlighter-rouge">0x10000000</code>地址8位数据，推测Term中调用的<code class="language-plaintext highlighter-rouge">socket</code>模块的<code class="language-plaintext highlighter-rouge">send</code>、<code class="language-plaintext highlighter-rouge">recv</code>函数也需要判断检验位后每次向串口地址<code class="language-plaintext highlighter-rouge">0x10000000</code>读/写8位数据。</p><h2 id="思考题目"><span class="mr-2">思考题目</span><a href="#思考题目" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ol><li><p><strong>比较 RISC-V 指令寻址方法与 x86 指令寻址方法的异同。</strong></p><p>RISC-V指令寻址方法只有一种（立即数与存放基址的寄存器相加，即基址+偏移量寻址），而x86指令寻址方法繁多（包含立即数寻址、寄存器寻址、绝对寻址、间接寻址、基址+偏移量寻址、2种变址寻址、4种比例变址寻址）。</p><p>RISC-V只有load, store访存指令（<code class="language-plaintext highlighter-rouge">lb</code>, <code class="language-plaintext highlighter-rouge">lw</code>, <code class="language-plaintext highlighter-rouge">sb</code>, <code class="language-plaintext highlighter-rouge">sw</code>等）可以访问内存，而x86基本所有指令（如移动指令<code class="language-plaintext highlighter-rouge">mov</code>、算术指令<code class="language-plaintext highlighter-rouge">add</code>等，以及x86本身的访存指令）均可以访问内存。</p><li><p><strong>阅读监控程序，列出监控程序的 19 条指令，请根据自己的理解对用到的指令进行分类，并说明分类原因。</strong></p><p>19条指令（参考了<em>《RISC-V手册》</em>）：</p><div class="table-wrapper"><table><thead><tr><th style="text-align: left">指令<th style="text-align: left">描述<th style="text-align: left">具体含义<tbody><tr><td style="text-align: left"><strong>add</strong> rd, rs1, rs2<td style="text-align: left">x[rd] = x[rs1] + x[rs2]<td style="text-align: left">把寄存器 x[rs2]加到寄存器x[rs1]上，结果写入x[rd]（忽略算术溢出）<tr><td style="text-align: left"><strong>addi</strong> rd, rs, imm<td style="text-align: left">x[rd] = x[rs] + sext(imm)<td style="text-align: left">把符号位扩展的立即数加到寄存器x[rs]上，结果写入x[rd]（忽略算术溢出）<tr><td style="text-align: left"><strong>and</strong> rd, rs1, rs2<td style="text-align: left">x[rd] = x[rs1] &amp; x[rs2]<td style="text-align: left">将寄存器 x[rs1]和寄存器x[rs2]位与的结果写入x[rd]<tr><td style="text-align: left"><strong>andi</strong> rd, rs, imm<td style="text-align: left">x[rd] = x[rs] &amp; sext(imm)<td style="text-align: left">把符号位扩展的立即数和寄存器x[rs]上的值进行位与，结果写入x[rd]<tr><td style="text-align: left"><strong>auipc</strong> rd, imm<td style="text-align: left">x[rd] = pc + sext(imm[31:12] « 12)<td style="text-align: left">把符号位扩展的20位（左移12位）立即数加到pc上，结果写入x[rd]<tr><td style="text-align: left"><strong>beq</strong> rs1, rs2, offset<td style="text-align: left">if (x[rs1] == x[rs2]) pc += sext(offset)<td style="text-align: left">若寄存器x[rs1]和寄存器x[rs2]的值相等，把pc的值设为当前值加上符号位扩展的偏移offset<tr><td style="text-align: left"><strong>bne</strong> rs1, rs2, offset<td style="text-align: left">if (x[rs1] ≠ x[rs2]) pc += sext(offset)<td style="text-align: left">若寄存器x[rs1]和寄存器x[rs2]的值不相等，把pc的值设为当前值加上符号位扩展的偏移offset<tr><td style="text-align: left"><strong>jal</strong> rd, offset<td style="text-align: left">x[rd] = pc+4; pc += sext(offset)<td style="text-align: left">把下一条指令的地址(pc+4)写入x[rd]，然后把pc设置为当前值加上符号位扩展的offset<tr><td style="text-align: left"><strong>jalr</strong> rd, offset(rs)<td style="text-align: left">t=pc+4; pc=(x[rs]+sext(offset))&amp;~1; x[rd]=t<td style="text-align: left">把pc设置为x[rs]+sext(offset)，把计算出的地址的最低有效位设为 0，并将原pc+4的值写入x[rd]（rd默认为x1）<tr><td style="text-align: left"><strong>lb</strong> rd, offset(rs)<td style="text-align: left">x[rd] = sext(M[x[rs] + sext(offset)][7:0])<td style="text-align: left">从地址x[rs]+sext(offset)读取一个字节（8位），经符号位扩展后写入x[rd]<tr><td style="text-align: left"><strong>lui</strong> rd, imm<td style="text-align: left">x[rd] = sext(imm[31:12] « 12)<td style="text-align: left">将符号位扩展的20位立即数imm左移12位，写入x[rd]中（低12位置零）<tr><td style="text-align: left"><strong>lw</strong> rd, offset(rs)<td style="text-align: left">x[rd] = sext(M[x[rs] + sext(offset)][31:0])<td style="text-align: left">从地址x[rs]+sext(offset)读取四个字节，写入x[rd]<tr><td style="text-align: left"><strong>or</strong> rd, rs1, rs2<td style="text-align: left">x[rd] = x[rs1] | x[rs2]<td style="text-align: left">把寄存器x[rs1]和寄存器x[rs2]按位取或，结果写入x[rd]<tr><td style="text-align: left"><strong>ori</strong> rd, rs, imm<td style="text-align: left">x[rd] = x[rs] | sext(imm)<td style="text-align: left">把寄存器x[rs]和符号扩展的立即数imm按位取或，结果写入x[rd]<tr><td style="text-align: left"><strong>sb</strong> rs2, offset(rs1)<td style="text-align: left">M[x[rs1] + sext(offset)] = x[rs2][7:0]<td style="text-align: left">将x[rs2]的低8位存入内存地址x[rs1]+sext(offset)<tr><td style="text-align: left"><strong>slli</strong> rd, rs, shamt<td style="text-align: left">x[rd] = x[rs] « shamt<td style="text-align: left">把寄存器x[rs]逻辑左移shamt位，空出的位置填入0，结果写入x[rd]（对于RV32I，仅当shamt[5]=0时，指令才有效）<tr><td style="text-align: left"><strong>srli</strong> rd, rs, shamt<td style="text-align: left">x[rd] = x[rs] » shamt<td style="text-align: left">把寄存器x[rs]逻辑右移shamt位，空出的位置填入0，结果写入x[rd]（对于RV32I，仅当shamt[5]=0时，指令才有效）<tr><td style="text-align: left"><strong>sw</strong> rs2, offset(rs1)<td style="text-align: left">M[x[rs1] + sext(offset)] = x[rs2][31:0]<td style="text-align: left">将x[rs2]的低位4个字节存入内存地址x[rs1]+sext(offset)<tr><td style="text-align: left"><strong>xor</strong> rd, rs1, rs2<td style="text-align: left">x[rd] = x[rs1] ^ x[rs2]<td style="text-align: left">x[rs1]和x[rs2]按位异或，结果写入x[rd]</table></div><blockquote><p><em>x[id]表示编号为id的寄存器，rd表示destination register目标寄存器的编号，rs表示source register源寄存器的编号，sext表示sign-extend符号位扩展，imm表示immediate立即数，pc表示program counter程序计数器寄存器，offset为立即数形式的偏移量，M[address]表示地址为address的内存空间，shamt为立即数形式的位移量。</em></p></blockquote><p>分类：</p><div class="table-wrapper"><table><thead><tr><th>分类<th>指令<th>原因<tbody><tr><td>整数计算指令<td>ADD, ADDI, AND, ANDI, SLLI, SRLI, OR, ORI, XOR, LUI, AUIPC<td>需要调用ALU，包含算术指令（ADD, ADDI）、逻辑指令（AND, ANDI, OR, ORI, XOR）、移位指令（SLLI, SRLI）、其他（向PC高位加上立即数的AUIPC, 加载立即数到高位的LUI）<tr><td>条件分支指令<td>BEQ, BNE<td>根据比较结果进行分支跳转<tr><td>无条件跳转指令<td>JAL, JALR<td>实现无条件的跳转并链接<tr><td>访存指令<td>LB, LW, SB, SW<td>从/向内存加载、存储数据</table></div><li><p><strong>结合 term 源代码和 kernel 源代码说明 term 是如何实现用户程序计时的。</strong></p><p>主要思路是，Kernel获得用户程序地址后通过串口发送开始计时信号<code class="language-plaintext highlighter-rouge">SIG_TIMERSET</code>来通知Term用户程序开始运行，Term处开始计时（记录开始时间），Kernel执行完用户程序并复原调用用户代码前的寄存器、栈顶指针后通过串口发送停止计时信号<code class="language-plaintext highlighter-rouge">SIG_TIMETOKEN</code>来通知Term用户程序结束运行，Term处停止计时并获得用户程序运行时间（计算结束时间与先前记录的开始时间之差）。</p><p>具体流程为：</p><ol><li>Term在<code class="language-plaintext highlighter-rouge">term.py</code>文件中的<code class="language-plaintext highlighter-rouge">run_G</code>函数中，将指令<code class="language-plaintext highlighter-rouge">G</code>与用户程序代码所在的8位内存地址通过串口写给Kernel；<li>Kernel在<code class="language-plaintext highlighter-rouge">shell.S</code>文件的<code class="language-plaintext highlighter-rouge">SHELL</code>函数中从串口中读入Term发来的<code class="language-plaintext highlighter-rouge">G</code>指令并跳转到<code class="language-plaintext highlighter-rouge">.OP_G</code>子函数中，再从串口中读入Term发来的用户程序代码所在的8位内存地址并保存到<code class="language-plaintext highlighter-rouge">s10</code>寄存器，然后在执行用户程序（跳转到<code class="language-plaintext highlighter-rouge">s10</code>所存内存地址处）之前，通过串口向Term写入开始计时信号<code class="language-plaintext highlighter-rouge">SIG_TIMERSET</code>（即<code class="language-plaintext highlighter-rouge">0x06</code>，在ASCII中表示ACK，为不可见ASCII字符）；<li>Term通过串口读入Kernel发来的数据，并判断是否为约定好的开始计时信号<code class="language-plaintext highlighter-rouge">SIG_TIMERSET</code>（即<code class="language-plaintext highlighter-rouge">0x06</code>），若是则通过<code class="language-plaintext highlighter-rouge">time_start = timer()</code>开始计时（记录开始时间）；<li>Kernel此时写入返回地址<code class="language-plaintext highlighter-rouge">la ra, .USERRET2</code>到<code class="language-plaintext highlighter-rouge">ra</code>后开始执行用户程序，即<code class="language-plaintext highlighter-rouge">jr s10</code>跳转到用户程序所在的内存地址<code class="language-plaintext highlighter-rouge">s10</code>处，同时Term通过<code class="language-plaintext highlighter-rouge">while True:</code>循环不断判断从串口处读入的数据是否是约定好的停止计时信号<code class="language-plaintext highlighter-rouge">SIG_TIMETOKEN</code>（即<code class="language-plaintext highlighter-rouge">0x07</code>，在ASCII中表示BEL，为不可见ASCII字符）——<li>若Term读入的不是停止计时信号<code class="language-plaintext highlighter-rouge">SIG_TIMETOKEN</code>（且也不是超时信号<code class="language-plaintext highlighter-rouge">SIG_TIMEOUT</code>即<code class="language-plaintext highlighter-rouge">0x81 </code>）则默认为Kernel向Term发送的待输出到终端的可见字符，调用<code class="language-plaintext highlighter-rouge">output_binary</code>函数将其输出到终端；<li>直到Kernel执行完用户程序（进入<code class="language-plaintext highlighter-rouge">.USERRET2</code>子函数并完成调用用户程序之前的寄存器、栈顶指针复原），通过串口向Term写入停止计时信号<code class="language-plaintext highlighter-rouge">SIG_TIMETOKEN</code>；<li>因此此时Term再通过<code class="language-plaintext highlighter-rouge">while</code>循环从串口读入的就是停止计时信号<code class="language-plaintext highlighter-rouge">SIG_TIMETOKEN</code>（即<code class="language-plaintext highlighter-rouge">0x07</code>），终止<code class="language-plaintext highlighter-rouge">while</code>循环并通过<code class="language-plaintext highlighter-rouge">elapse = timer() - time_start</code>停止计时并获得用户程序运行时间（计算结束时间与先前记录的开始时间之差）。</ol><li><p><strong>说明 kernel 是如何使用串口的（在源代码中，这部分有针对 FPGA 与 QEMU 两个版本的代码，任选其一进行分析即可）。</strong></p><p>如<code class="language-plaintext highlighter-rouge">supervisor-rv/kernel/include/serial.h</code>文件中定义的，FPGA与QEMU的串口地址常量均由<code class="language-plaintext highlighter-rouge">COM1</code>表示、串口的寄存器地址间隔均由<code class="language-plaintext highlighter-rouge">COM_MULTIPLY</code>表示、串口是否可读/可写的判断地址相对于串口地址的偏移量均由<code class="language-plaintext highlighter-rouge">COM_LSR_OFFSET</code>表示（即判断可读/可写状态位的判断地址实际为<code class="language-plaintext highlighter-rouge">COM1 + COM_LSR_OFFSET</code>）、写状态位均由<code class="language-plaintext highlighter-rouge">COM_LSR_THRE</code>表示、读状态位均由<code class="language-plaintext highlighter-rouge">COM_LSR_DR</code>表示。</p><p>详见上一章代码分析报告中<a href="#1">交互流程</a>一节，以QEMU为例（即<code class="language-plaintext highlighter-rouge">COM1 = 0x10000000</code>, <code class="language-plaintext highlighter-rouge">COM_MULTIPLY = 1</code>, ` COM_LSR_OFFSET = 5<code class="language-plaintext highlighter-rouge">, </code>COM_LSR_THRE = 0x20<code class="language-plaintext highlighter-rouge">, </code>COM_LSR_DR = 0x01<code class="language-plaintext highlighter-rouge">）分析了Kernel如何使用串。（FPGA相应的各常量为</code>COM1 = AXI Uart16550的基地址 + 0x10000<code class="language-plaintext highlighter-rouge">, </code>COM_MULTIPLY = 4<code class="language-plaintext highlighter-rouge">, </code> COM_LSR_OFFSET = 20<code class="language-plaintext highlighter-rouge">, </code>COM_LSR_THRE = 0x20<code class="language-plaintext highlighter-rouge">, </code>COM_LSR_DR = 0x01`）。</p><li><p><strong>请问 term 如何检查 kernel 已经正确连入，并分别指出检查代码在 term 与 kernel 源码中的位置。</strong></p><p>检查代码在Term源码中的<code class="language-plaintext highlighter-rouge">term.py</code>文件<code class="language-plaintext highlighter-rouge">main</code>函数调用<code class="language-plaintext highlighter-rouge">InitializeTCP</code>函数中<code class="language-plaintext highlighter-rouge">ser.connect(host, int(port))</code>语句，其中<code class="language-plaintext highlighter-rouge">ser</code>是类<code class="language-plaintext highlighter-rouge">tcp_wrapper</code>的对象，<code class="language-plaintext highlighter-rouge">tcp_wrapper</code>的成员函数<code class="language-plaintext highlighter-rouge">connect</code>内部实际上调用了Python的stdlib库中socket模块所定义的<code class="language-plaintext highlighter-rouge">connect</code>函数。</p><p>检查代码在Kernel源码中的<code class="language-plaintext highlighter-rouge">shell.S</code>文件<code class="language-plaintext highlighter-rouge">SHELL</code>函数<code class="language-plaintext highlighter-rouge">li a0, XLEN</code>与<code class="language-plaintext highlighter-rouge">jal WRITE_SERIAL</code>指令（后续又跳转到<code class="language-plaintext highlighter-rouge">utils.S</code>文件<code class="language-plaintext highlighter-rouge">WRITE_SERIAL</code>函数以将<code class="language-plaintext highlighter-rouge">XLEN</code>写入串口给Term）。</p><p>Term如何检查Kernel已经正确连入，分析如下——</p><p>观察Term连接Kernel的过程：</p><div class="language-bash highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre>➜  kernel git:<span class="o">(</span>master<span class="o">)</span> ✗ make sim
riscv64-unknown-elf-ld  obj/evec.o  obj/init.o  obj/shell.o  obj/test.o  obj/trap.o  obj/utils.o <span class="nt">-Tkern</span>/kernel32.ld
qemu-system-riscv32 <span class="nt">-M</span> virt <span class="nt">-m</span> 32M <span class="nt">-kernel</span> kernel.elf <span class="nt">-nographic</span> <span class="nt">-monitor</span> none <span class="nt">-serial</span> tcp::6666,server <span class="nt">-s</span> <span class="nt">-bios</span> none
qemu-system-riscv32: <span class="nt">-serial</span> tcp::6666,server: info: QEMU waiting <span class="k">for </span>connection on: disconnected:tcp::::6666,server<span class="o">=</span>on
</pre></table></code></div></div><div class="language-bash highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre>➜  term git:<span class="o">(</span>master<span class="o">)</span> ✗ python3 term.py <span class="nt">-t</span> 127.0.0.1:6666
connecting to 127.0.0.1:6666...connected
MONITOR <span class="k">for </span>RISC-V - initialized.
running <span class="k">in </span>32bit, xlen <span class="o">=</span> 4
<span class="o">&gt;&gt;</span>
</pre></table></code></div></div><p>完整连接过程（包含<strong>检查是否正确连入</strong>）分为以下几步：</p><ol><li>一旦启动Kernel（执行<code class="language-plaintext highlighter-rouge">make sim</code>指令），Kernel就已经完成<code class="language-plaintext highlighter-rouge">evec.S</code>与<code class="language-plaintext highlighter-rouge">init.S</code>中代码的运行（此处包含①各种必要的初始化，②通过模拟器QEMU设置好的host为本机、端口为<code class="language-plaintext highlighter-rouge">6666</code>的TCP服务器以等待Term的连接并配置好串口，③以及向串口写入定义为<code class="language-plaintext highlighter-rouge">monitor_version</code>的文本数据<code class="language-plaintext highlighter-rouge">"MONITOR for RISC-V - initialized."</code>——注意此处只是向串口写入，Term并没有读取该数据，Term甚至还没有连接上Kernel呢），并进入<code class="language-plaintext highlighter-rouge">shell.S</code>中<code class="language-plaintext highlighter-rouge">SHELL</code>函数中，第一行的<code class="language-plaintext highlighter-rouge">jal READ_SERIAL</code>跳转到<code class="language-plaintext highlighter-rouge">utils.S</code>的读操作符函数中，忙等待Term在连接上Kernel之后通过串口向Kernel发送操作符<code class="language-plaintext highlighter-rouge">W</code>，好让Kernel通过串口把<code class="language-plaintext highlighter-rouge">XLEN</code>写给Term（注意此处Kernel一直卡在函数<code class="language-plaintext highlighter-rouge">READ_SERIAL</code>中的子函数<code class="language-plaintext highlighter-rouge">.TESTR</code>进行轮询检测验证，因为Term此时还没给Kernel发送任何数据，因此串口检测地址的可读位始终为0，Term甚至还没连接上Kernel呢）；<li>反观Term，由用户在终端敲入<code class="language-plaintext highlighter-rouge">python3 term.py -t 127.0.0.1:6666</code>命令，Term在<code class="language-plaintext highlighter-rouge">term.py</code>的<code class="language-plaintext highlighter-rouge">main</code>函数中通过<code class="language-plaintext highlighter-rouge">args = parser.parse_args()</code>从命令行读入<code class="language-plaintext highlighter-rouge">args.tcp = 127.0.0.1:6666 </code>，并作为参数<code class="language-plaintext highlighter-rouge">host_port</code>传入<code class="language-plaintext highlighter-rouge">InitializeTCP(host_port)</code>函数；<li>在<code class="language-plaintext highlighter-rouge">InitializeTCP</code>函数中，若用户输入的<code class="language-plaintext highlighter-rouge">host_port</code>不满足<code class="language-plaintext highlighter-rouge">host</code>与<code class="language-plaintext highlighter-rouge">port</code>的正则表达式，则直接返回到<code class="language-plaintext highlighter-rouge">main</code>函数中输出<code class="language-plaintext highlighter-rouge">print('Failed to establish TCP connection')</code>退出程序，也就是完全没有执行任何连接相关操作；<li>若用户输入的<code class="language-plaintext highlighter-rouge">host_port</code>在语法上是合法的，则Term创建<code class="language-plaintext highlighter-rouge">tcp_wrapper</code>类的<code class="language-plaintext highlighter-rouge">ser = tcp_wrapper()</code>对象，在终端输出<code class="language-plaintext highlighter-rouge">"connecting to 127.0.0.1:6666..."</code>，并调用<code class="language-plaintext highlighter-rouge">socket</code>模块（Python的stdlib库自带模块）的<code class="language-plaintext highlighter-rouge">ser.connect(host, int(port))</code>连接函数进行连接与<strong>检查是否正确连入</strong>的操作（若连接成功则顺序执行<code class="language-plaintext highlighter-rouge">print("connected")</code>输出连接成功，若连接失败则由<code class="language-plaintext highlighter-rouge">socket</code>库的<code class="language-plaintext highlighter-rouge">connect</code>函数提供报错信息如<code class="language-plaintext highlighter-rouge">ConnectionRefusedError: [Errno 61] Connection refused</code>并退出程序）；<li>连接成功后（终端输出<code class="language-plaintext highlighter-rouge">"connected"</code>），Term跳转到<code class="language-plaintext highlighter-rouge">Main</code>函数，通过<code class="language-plaintext highlighter-rouge">inp.read</code>从串口中读入步骤1.中Kernel往串口中写入的<code class="language-plaintext highlighter-rouge">monitor_version</code>文本数据，并打印在终端；<li>然后Term再向串口<code class="language-plaintext highlighter-rouge">outp.write(b'W')</code>写入操作符<code class="language-plaintext highlighter-rouge">W</code>，如步骤1.所提到的，Kernel在<code class="language-plaintext highlighter-rouge">READ_SERIAL</code>函数中的子函数<code class="language-plaintext highlighter-rouge">.TESTR</code>轮询进行检测验证，终于验证到了可读位为1（因为Term终于向Kernel发送了数据<code class="language-plaintext highlighter-rouge">W</code>，串口检测地址的可读位从0变成1），顺序执行读取操作符<code class="language-plaintext highlighter-rouge">W</code>，并返回到<code class="language-plaintext highlighter-rouge">SHELL</code>函数中，执行<code class="language-plaintext highlighter-rouge">li a0, XLEN</code>与<code class="language-plaintext highlighter-rouge">jal WRITE_SERIAL</code>，即将机器字长<code class="language-plaintext highlighter-rouge">XLEN</code>（版本号）通过串口写给Term，该功能作为<strong>检查是否正确连入</strong>的标志，之后Kernel将等待Term从串口发来的Term命令；<li>Term读取串口<code class="language-plaintext highlighter-rouge">xlen = ord(inp.read(1))</code>获得机器字长并输出到终端<code class="language-plaintext highlighter-rouge">"running in 32bit, xlen = 4"</code>，随后进入<code class="language-plaintext highlighter-rouge">MainLoop</code>函数由用户输入Term命令，后续再与Kernel交互，不再阐释。</ol></ol></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/posts/'>posts</a>, <a href='/categories/computer-science/'>computer-science</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/blog/" class="post-tag no-text-decoration" >blog</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=%E8%AE%A1%E7%BB%84%E5%AE%9E%E9%AA%8C1%EF%BC%9A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E4%B8%8E%E7%9B%91%E6%8E%A7%E7%A8%8B%E5%BA%8F+-+Hanna%27s+Site&url=https%3A%2F%2Fhanna0911.github.io%2Fposts%2Friscv-homework%2F" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=%E8%AE%A1%E7%BB%84%E5%AE%9E%E9%AA%8C1%EF%BC%9A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E4%B8%8E%E7%9B%91%E6%8E%A7%E7%A8%8B%E5%BA%8F+-+Hanna%27s+Site&u=https%3A%2F%2Fhanna0911.github.io%2Fposts%2Friscv-homework%2F" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=https%3A%2F%2Fhanna0911.github.io%2Fposts%2Friscv-homework%2F&text=%E8%AE%A1%E7%BB%84%E5%AE%9E%E9%AA%8C1%EF%BC%9A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E4%B8%8E%E7%9B%91%E6%8E%A7%E7%A8%8B%E5%BA%8F+-+Hanna%27s+Site" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <a href="https://www.linkedin.com/sharing/share-offsite/?url=https%3A%2F%2Fhanna0911.github.io%2Fposts%2Friscv-homework%2F" data-toggle="tooltip" data-placement="top" title="Linkedin" target="_blank" rel="noopener" aria-label="Linkedin"> <i class="fa-fw fab fa-linkedin"></i> </a> <a href="http://service.weibo.com/share/share.php?title=%E8%AE%A1%E7%BB%84%E5%AE%9E%E9%AA%8C1%EF%BC%9A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E4%B8%8E%E7%9B%91%E6%8E%A7%E7%A8%8B%E5%BA%8F+-+Hanna%27s+Site&url=https%3A%2F%2Fhanna0911.github.io%2Fposts%2Friscv-homework%2F" data-toggle="tooltip" data-placement="top" title="Weibo" target="_blank" rel="noopener" aria-label="Weibo"> <i class="fa-fw fab fa-weibo"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copy link" data-title-succeed="Link copied successfully!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">Recently Updated</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/riscv-homework/">计组实验1：汇编语言与监控程序</a><li><a href="/posts/network-darpa/">与时代相互选择，极简所带来的无限可能</a><li><a href="/posts/bioinfo-hw2/">生信 Week 2 作业</a><li><a href="/posts/first-blog/">首条博客：网站创建成功~</a><li><a href="/posts/bioinfo-hw1/">生信 Week 1 作业</a></ul></div><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/blog/">blog</a> <a class="post-tag" href="/tags/nothing/">nothing</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">Contents</div><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 pl-3 pr-3 pr-xl-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/network-darpa/"><div class="card-body"> <em class="small" data-ts="1665064200" data-df="ll" > Oct 6, 2022 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>与时代相互选择，极简所带来的无限可能</h3><div class="text-muted small"><p> 读《DARPA 互联网协议的设计理念》有感 文献：David D. Clark. “The Design Philosophy of the DARPA Internet Protocols”, In: Proceedings of ACM SIGCOMM’88, Aug. 1988. 论文中讲述了基于TCP/IP协议的DARPA互联网架构的设计理念，包括互联网所要实现的目标...</p></div></div></a></div><div class="card"> <a href="/posts/first-blog/"><div class="card-body"> <em class="small" data-ts="1663419247" data-df="ll" > Sep 17, 2022 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>首条博客：网站创建成功~</h3><div class="text-muted small"><p> 并没有什么内容的博客哈哈，贴一下老师的作业要求吧！ 注册一个GitHub账户，创建一个repo(仓库)，写好README.md。尝试使用Git（初学者可以用github的桌面版软件）管理自己的代码并同步GitHub云端和本地文件。 尝试使用Markdown语言，熟悉其语法，利用github的github page功能，用markdown写一个自己的网页。...</p></div></div></a></div><div class="card"> <a href="/posts/bioinfo-hw1/"><div class="card-body"> <em class="small" data-ts="1663432360" data-df="ll" > Sep 17, 2022 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>生信 Week 1 作业</h3><div class="text-muted small"><p> PART I-2.Liunx-2.2.Practice Guide 提交word/md/txt/sh文件均可 第2，3题要求给出结果，并附上使用的命令 解释1.gtf文件中第4、5列代表什么，exon长度应该是$5-$4+1还是$5-$4？ 第4列start代表基因组起始位置坐标（从1开始，闭区间），第5列end代表基因组终止位置坐标（从1开始...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/first-blog/" class="btn btn-outline-primary" prompt="Older"><p>首条博客：网站创建成功~</p></a> <a href="/posts/bioinfo-hw1/" class="btn btn-outline-primary" prompt="Newer"><p>生信 Week 1 作业</p></a></div></div></div><footer class="row pl-3 pr-3"><div class="col-12 d-flex justify-content-between align-items-center text-muted pl-0 pr-0"><div class="footer-left"><p class="mb-0"> © 2024 <a href="https://github.com/hanna0911">Hanna Wang</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/blog/">blog</a> <a class="post-tag" href="/tags/nothing/">nothing</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><script src="https://cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js"></script> <script> $(function() { function updateMermaid(event) { if (event.source === window && event.data && event.data.direction === ModeToggle.ID) { const mode = event.data.message; if (typeof mermaid === "undefined") { return; } let expectedTheme = (mode === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* Re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } let initTheme = "default"; if ($("html[data-mode=dark]").length > 0 || ($("html[data-mode]").length == 0 && window.matchMedia("(prefers-color-scheme: dark)").matches ) ) { initTheme = "dark"; } let mermaidConf = { theme: initTheme /* <default|dark|forest|neutral> */ }; /* Markdown converts to HTML */ $("pre").has("code.language-mermaid").each(function() { let svgCode = $(this).children().html(); $(this).addClass("unloaded"); $(this).after(`<div class=\"mermaid\">${svgCode}</div>`); }); mermaid.initialize(mermaidConf); window.addEventListener("message", updateMermaid); }); </script><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a><div id="notification" class="toast" role="alert" aria-live="assertive" aria-atomic="true" data-animation="true" data-autohide="false"><div class="toast-header"> <button type="button" class="ml-2 ml-auto close" data-dismiss="toast" aria-label="Close"> <span aria-hidden="true">&times;</span> </button></div><div class="toast-body text-center pt-0"><p class="pl-2 pr-2 mb-3">A new version of content is available.</p><button type="button" class="btn btn-primary" aria-label="Update"> Update </button></div></div><script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No results found.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lozad/dist/lozad.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/en.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script> /* see: <https://docs.mathjax.org/en/latest/options/input/tex.html#tex-options> */ MathJax = { tex: { inlineMath: [ /* start/end delimiter pairs for in-line math */ ['$','$'], ['\\(','\\)'] ], displayMath: [ /* start/end delimiter pairs for display math */ ['$$', '$$'], ['\\[', '\\]'] ] } }; </script> <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"> </script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/app.js"></script>
