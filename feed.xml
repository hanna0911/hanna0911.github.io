<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator><link href="https://hanna0911.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://hanna0911.github.io/" rel="alternate" type="text/html" hreflang="en" /><updated>2024-01-08T05:37:27+00:00</updated><id>https://hanna0911.github.io/feed.xml</id><title type="html">Hanna’s Site</title><subtitle>Hello, a site built to test out how markdown can be used to build a website~</subtitle><entry><title type="html">测试中文NetlifyCMS</title><link href="https://hanna0911.github.io/posts/%E6%B5%8B%E8%AF%95%E4%B8%AD%E6%96%87netlifycms/" rel="alternate" type="text/html" title="测试中文NetlifyCMS" /><published>2024-01-08T01:33:54+00:00</published><updated>2024-01-08T01:33:54+00:00</updated><id>https://hanna0911.github.io/posts/%E6%B5%8B%E8%AF%95%E4%B8%AD%E6%96%87netlifycms</id><content type="html" xml:base="https://hanna0911.github.io/posts/%E6%B5%8B%E8%AF%95%E4%B8%AD%E6%96%87netlifycms/">&lt;blockquote&gt;
  &lt;p&gt;读《DARPA 互联网协议的设计理念》有感&lt;/p&gt;

  &lt;p&gt;文献：David D. Clark. “The Design Philosophy of the DARPA Internet Protocols”, In: Proceedings of ACM SIGCOMM’88, Aug. 1988.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;论文中讲述了基于TCP/IP协议的DARPA互联网架构的设计理念，包括互联网所要实现的目标（主要目标：互联；二级目标：鲁棒、服务通用、网络通用、分布式管理、低成本高效益、互联便捷、资源可计量，优先级依次递减）和为了实现这些目标所选取的基本架构（分组交换、存储转发）。&lt;/p&gt;</content><author><name></name></author><category term="posts" /><category term="nothing" /><category term="blog" /><summary type="html">读《DARPA 互联网协议的设计理念》有感 文献：David D. Clark. “The Design Philosophy of the DARPA Internet Protocols”, In: Proceedings of ACM SIGCOMM’88, Aug. 1988.</summary></entry><entry><title type="html">测试netlifyCMS发帖</title><link href="https://hanna0911.github.io/posts/%E6%B5%8B%E8%AF%95netlifycms%E5%8F%91%E5%B8%96/" rel="alternate" type="text/html" title="测试netlifyCMS发帖" /><published>2024-01-08T01:05:56+00:00</published><updated>2024-01-08T01:05:56+00:00</updated><id>https://hanna0911.github.io/posts/%E6%B5%8B%E8%AF%95netlifycms%E5%8F%91%E5%B8%96</id><content type="html" xml:base="https://hanna0911.github.io/posts/%E6%B5%8B%E8%AF%95netlifycms%E5%8F%91%E5%B8%96/">&lt;blockquote&gt;
  &lt;p&gt;c﻿an’t write chinese?&lt;/p&gt;

  &lt;p&gt;w﻿hat?&lt;/p&gt;

  &lt;p&gt;﻿&lt;/p&gt;

  &lt;p&gt;w﻿hat?&lt;/p&gt;
&lt;/blockquote&gt;</content><author><name></name></author><category term="nothing" /><summary type="html">c﻿an’t write chinese? w﻿hat? ﻿ w﻿hat?</summary></entry><entry><title type="html">生信 Week 2 作业</title><link href="https://hanna0911.github.io/posts/bioinfo-hw2/" rel="alternate" type="text/html" title="生信 Week 2 作业" /><published>2022-10-08T11:50:25+00:00</published><updated>2022-10-08T11:57:52+00:00</updated><id>https://hanna0911.github.io/posts/bioinfo-hw2</id><content type="html" xml:base="https://hanna0911.github.io/posts/bioinfo-hw2/">&lt;h2 id=&quot;hw2-必做题&quot;&gt;HW2 必做题&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Blast sequences&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;请使用网页版的 blastp, 将上面的蛋白序列只与 mouse protein database 进行比对， 设置输出结果最多保留10个， E 值最大为 0.5。将操作过程和结果截图。&lt;/strong&gt;&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt; blast的网站会提供多个mouse的databases，可以任选1个进行比对；也可以重复几次，每次选一个不同的database看看不同的输出结果，可以在作业中比较和讨论一下输出结果不同的原因。&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;p&gt;操作：&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/assets/Screen Shot 2022-10-05 at 2.20.59 AM.png&quot; alt=&quot;Screen Shot 2022-10-05 at 2.20.59 AM&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/assets/Screen Shot 2022-10-05 at 2.21.28 AM.png&quot; alt=&quot;Screen Shot 2022-10-05 at 2.21.28 AM&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;结果：&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/assets/Screen Shot 2022-10-05 at 2.23.09 AM.png&quot; alt=&quot;Screen Shot 2022-10-05 at 2.23.09 AM&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/assets/Screen Shot 2022-10-05 at 2.23.26 AM.png&quot; alt=&quot;Screen Shot 2022-10-05 at 2.23.26 AM&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;请使用 Bash 脚本编程：将上面的蛋白序列随机打乱生成10个， 然后对这10个序列两两之间进行 blast 比对，输出并解释结果。（请上传bash脚本，注意做好重要code的注释；同时上传一个结果文件用来示例程序输出的结果以及你对这些结果的解释。）&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;&lt;em&gt;完整的代码文件以及生成的结果文件存放在&lt;a href=&quot;https://github.com/hanna0911/random-blastp&quot;&gt;仓库&lt;/a&gt;中，和该报告中的内容相同（仓库中多出clone文件夹中的10条随机序列文件、output文件夹中的所有blastp比对结果文件）。&lt;/em&gt;&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;bash脚本：&lt;/strong&gt;&lt;/p&gt;

    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;c&quot;&gt;#!/bin/bash&lt;/span&gt;
   
   
&lt;span class=&quot;c&quot;&gt;# 将原序列文件protein/VIM.fasta的内容读出到header, protein_string中&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;0
&lt;span class=&quot;k&quot;&gt;while &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;read &lt;/span&gt;line&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;do 
    if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$i&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-eq&lt;/span&gt; 0 &lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;then
        &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;header&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$line&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;else
        &lt;/span&gt;protein_string+&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$line&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;fi    
    &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;$((&lt;/span&gt;i+1&lt;span class=&quot;k&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;done&lt;/span&gt; &amp;lt; protein/VIM.fasta
   
&lt;span class=&quot;c&quot;&gt;# 将protein_string字符串按字符存到protein_array数组中&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;while &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;read&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-n&lt;/span&gt; 1 char &lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;do
    &lt;/span&gt;protein_array+&lt;span class=&quot;o&quot;&gt;=(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$char&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;done&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$protein_string&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
   
&lt;span class=&quot;c&quot;&gt;# 打乱函数（就地洗牌）&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;function &lt;/span&gt;shuffle &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nb&quot;&gt;local &lt;/span&gt;i tmp size rand
    &lt;span class=&quot;nv&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${#&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;protein_array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[*]&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;size-1&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; i&amp;gt;0&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; i--&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;do
        &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;rand&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;$((&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$RANDOM&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;i &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;))&lt;/span&gt;
        &lt;span class=&quot;c&quot;&gt;# swap&lt;/span&gt;
        &lt;span class=&quot;nv&quot;&gt;tmp&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;protein_array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[i]&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;
        protein_array[i]&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;protein_array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[rand]&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;
        protein_array[rand]&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$tmp&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;done&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
   
&lt;span class=&quot;c&quot;&gt;# 隔70个字符就换行（fasta文件序列输出美观）&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;function &lt;/span&gt;endline &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nb&quot;&gt;local &lt;/span&gt;i size remainer
    &lt;span class=&quot;nv&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${#&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;protein_array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[*]&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;0&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; i&amp;lt;size&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; i++&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;do
        &lt;/span&gt;new_protein_string+&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;protein_array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
        &lt;span class=&quot;nv&quot;&gt;remainer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;$((&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;70&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;))&lt;/span&gt; 
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$remainer&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; 69 &lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;then
            &lt;/span&gt;new_protein_string+&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;fi
    done&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
   
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-d&lt;/span&gt; clone &lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;mkdir &lt;/span&gt;clone  &lt;span class=&quot;c&quot;&gt;# 随机序列生成在clone文件夹中&lt;/span&gt;
   
   
&lt;span class=&quot;nv&quot;&gt;total&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;10  &lt;span class=&quot;c&quot;&gt;# 生成的随机序列个数为10个&lt;/span&gt;
   
&lt;span class=&quot;c&quot;&gt;# 将原蛋白序列随机打乱生成total=10个，并存储到fasta文件中&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;0&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; i&amp;lt;&lt;span class=&quot;nv&quot;&gt;$total&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; i++&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;do&lt;/span&gt;
       
    &lt;span class=&quot;c&quot;&gt;# 将原蛋白序列随机打乱&lt;/span&gt;
    shuffle
    &lt;span class=&quot;nv&quot;&gt;new_header&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&amp;gt;CLONE&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$i&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
    &lt;span class=&quot;nv&quot;&gt;new_protein_string&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&quot;&lt;/span&gt;
    &lt;span class=&quot;nv&quot;&gt;output&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;clone/clone&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$i&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;.fasta&quot;&lt;/span&gt;
       
    &lt;span class=&quot;c&quot;&gt;# 按fasta格式要求存储到文件&lt;/span&gt;
    endline
    &lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;new_header&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$output&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
    &lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-e&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;new_protein_string&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$output&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
   
&lt;span class=&quot;k&quot;&gt;done&lt;/span&gt; 
   
   
&lt;span class=&quot;c&quot;&gt;# 用blastp进行序列比对，并将结果生成到文件&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;function &lt;/span&gt;blast &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nv&quot;&gt;query&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;clone/clone&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$1&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;.fasta&quot;&lt;/span&gt;
    &lt;span class=&quot;nv&quot;&gt;subject&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;clone/clone&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$2&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;.fasta&quot;&lt;/span&gt;
    &lt;span class=&quot;nv&quot;&gt;output_blastp&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;output/blastp_&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$1_$2&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
    blastp &lt;span class=&quot;nt&quot;&gt;-query&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$query&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-subject&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$subject&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-out&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$output_blastp&lt;/span&gt;  &lt;span class=&quot;c&quot;&gt;# 核心blastp命令&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
   
   
&lt;span class=&quot;c&quot;&gt;# 读取并解析blastp生成的结果文件&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;function &lt;/span&gt;read_result &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
   
    &lt;span class=&quot;nb&quot;&gt;local &lt;/span&gt;i hit result_file valid_info score expect
   
    &lt;span class=&quot;nv&quot;&gt;result_file&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;output/blastp_&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$1_$2&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
    &lt;span class=&quot;nv&quot;&gt;valid_info&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;grep&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-A&lt;/span&gt; 3 &lt;span class=&quot;s2&quot;&gt;&quot;&amp;gt; CLONE&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$2&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$result_file&lt;/span&gt;&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;  &lt;span class=&quot;c&quot;&gt;# 获取&quot;&amp;gt; CLONE$2&quot;关键词往后3行内容&lt;/span&gt;
   
    &lt;span class=&quot;c&quot;&gt;# 仅分析结果文件中的Score和Expect&lt;/span&gt;
    &lt;span class=&quot;nv&quot;&gt;hit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;0  &lt;span class=&quot;c&quot;&gt;# 记录query和subject序列是否有hit&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;read &lt;/span&gt;line&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;do 
        if &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;grep&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-q&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;Score&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$line&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;then
            &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;hit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;1
            &lt;span class=&quot;nv&quot;&gt;IFS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;' '&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;read&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-r&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-a&lt;/span&gt; info_array &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$line&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
            &lt;span class=&quot;nv&quot;&gt;score&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;info_array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[2]&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;  &lt;span class=&quot;c&quot;&gt;# Score&lt;/span&gt;
            &lt;span class=&quot;nv&quot;&gt;IFS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;','&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;read&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-r&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-a&lt;/span&gt; expect_array &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;info_array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[7]&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
            &lt;span class=&quot;nv&quot;&gt;expect&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;expect_array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[0]&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;  &lt;span class=&quot;c&quot;&gt;# Expect&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;fi    
        &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;$((&lt;/span&gt;i+1&lt;span class=&quot;k&quot;&gt;))&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;done&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$valid_info&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
   
    &lt;span class=&quot;c&quot;&gt;# 输出比对的Score和Expect结果到result.txt文件中&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$hit&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-eq&lt;/span&gt; 1 &lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;then 
        &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;CLONE&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$1&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt; vs CLONE&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$2&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;: Score = &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$score&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;, Expect = &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$expect&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;result.txt&quot;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;else
        &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;CLONE&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$1&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt; vs CLONE&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$2&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;: No hit&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;result.txt&quot;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;fi&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
   
   
&lt;span class=&quot;c&quot;&gt;# 对生成的total=10个随机序列两两之间进行blast比对并读取解析结果&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;0&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; i&amp;lt;&lt;span class=&quot;nv&quot;&gt;$total&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;-1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; i++&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;do
    for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;i+1&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; j&amp;lt;&lt;span class=&quot;nv&quot;&gt;$total&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; j++&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;do
        &lt;/span&gt;blast &lt;span class=&quot;nv&quot;&gt;$i&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$j&lt;/span&gt;  &lt;span class=&quot;c&quot;&gt;# blast比对&lt;/span&gt;
        read_result &lt;span class=&quot;nv&quot;&gt;$i&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$j&lt;/span&gt;  &lt;span class=&quot;c&quot;&gt;# 读取解析结果&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;done
done&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;&lt;strong&gt;结果文件：&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;需要注意的是，运行bash脚本得到的文件分为三类：&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;10条随机序列：生成到&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;clone&lt;/code&gt;文件夹中，文件命名为&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;clone/clone{id}.fasta&lt;/code&gt;，文件格式为fasta格式，header统一为&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;gt;CLONE{id}&lt;/code&gt;，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;id&lt;/code&gt;取值范围是0~9&lt;/li&gt;
      &lt;li&gt;10条序列两两比对的blastp结果：生成到&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;output&lt;/code&gt;文件夹中，文件命名为&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;output/blastp_{query_id}_{subject_id}&lt;/code&gt;，为blastp指令自动生成的结果文件，其中&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;query_id&lt;/code&gt;和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;subject_id&lt;/code&gt;取值范围是0~9且二者不相等&lt;/li&gt;
      &lt;li&gt;汇总所有比对的简要结果：将blastp结果文件提取简要信息（最多一条alignment结果的Score和Expect）生成到&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;result.txt&lt;/code&gt;文件中&lt;/li&gt;
    &lt;/ol&gt;

    &lt;p&gt;以下只显示第三种，即&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;result.txt&lt;/code&gt;文件：&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;CLONE0 vs CLONE1: Score = 17.3, Expect = 1.1
CLONE0 vs CLONE2: Score = 15.0, Expect = 5.8
CLONE0 vs CLONE3: Score = 18.9, Expect = 0.33
CLONE0 vs CLONE4: Score = 17.3, Expect = 1.3
CLONE0 vs CLONE5: Score = 17.3, Expect = 1.1
CLONE0 vs CLONE6: Score = 16.9, Expect = 1.5
CLONE0 vs CLONE7: Score = 15.8, Expect = 3.8
CLONE0 vs CLONE8: Score = 21.9, Expect = 0.037
CLONE0 vs CLONE9: Score = 14.2, Expect = 9.3
CLONE1 vs CLONE2: Score = 19.6, Expect = 0.24
CLONE1 vs CLONE3: Score = 16.5, Expect = 1.9
CLONE1 vs CLONE4: Score = 16.9, Expect = 1.4
CLONE1 vs CLONE5: Score = 18.5, Expect = 0.44
CLONE1 vs CLONE6: Score = 16.5, Expect = 2.1
CLONE1 vs CLONE7: Score = 16.9, Expect = 1.3
CLONE1 vs CLONE8: Score = 16.2, Expect = 2.5
CLONE1 vs CLONE9: Score = 18.9, Expect = 0.38
CLONE2 vs CLONE3: Score = 15.4, Expect = 4.6
CLONE2 vs CLONE4: Score = 18.1, Expect = 0.69
CLONE2 vs CLONE5: Score = 17.3, Expect = 1.1
CLONE2 vs CLONE6: Score = 16.2, Expect = 2.7
CLONE2 vs CLONE7: Score = 19.2, Expect = 0.32
CLONE2 vs CLONE8: Score = 17.3, Expect = 1.1
CLONE2 vs CLONE9: Score = 17.3, Expect = 1.2
CLONE3 vs CLONE4: Score = 16.5, Expect = 2.3
CLONE3 vs CLONE5: Score = 15.0, Expect = 5.5
CLONE3 vs CLONE6: Score = 16.2, Expect = 2.5
CLONE3 vs CLONE7: Score = 18.5, Expect = 0.56
CLONE3 vs CLONE8: Score = 17.3, Expect = 1.0
CLONE3 vs CLONE9: Score = 16.2, Expect = 2.3
CLONE4 vs CLONE5: Score = 18.5, Expect = 0.49
CLONE4 vs CLONE6: No hit
CLONE4 vs CLONE7: Score = 21.2, Expect = 0.071
CLONE4 vs CLONE8: Score = 18.1, Expect = 0.61
CLONE4 vs CLONE9: Score = 17.3, Expect = 1.1
CLONE5 vs CLONE6: Score = 16.2, Expect = 2.4
CLONE5 vs CLONE7: Score = 23.1, Expect = 0.019
CLONE5 vs CLONE8: Score = 15.0, Expect = 5.7
CLONE5 vs CLONE9: Score = 20.8, Expect = 0.10
CLONE6 vs CLONE7: Score = 17.3, Expect = 1.0
CLONE6 vs CLONE8: Score = 15.0, Expect = 6.1
CLONE6 vs CLONE9: Score = 17.3, Expect = 1.00
CLONE7 vs CLONE8: Score = 14.6, Expect = 8.6
CLONE7 vs CLONE9: Score = 18.1, Expect = 0.72
CLONE8 vs CLONE9: Score = 20.4, Expect = 0.12
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;&lt;strong&gt;对这些结果的解释：&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;其中将原蛋白序列随机打乱生成的10个新蛋白序列命名为CLONE0~CLONE9，且每两条序列间最多只取一组alignment的评分结果（取Score最高的一条）。对其比对的结果执行排序（优先按Score从大到小排，若Score相同则按Expect从小到大排）：&lt;/p&gt;

    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nb&quot;&gt;sort&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-k6nr&lt;/span&gt;,6 &lt;span class=&quot;nt&quot;&gt;-k9n&lt;/span&gt;,9 &lt;span class=&quot;s1&quot;&gt;'result.txt'&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;得到排序后的结果：&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;CLONE5 vs CLONE7: Score = 23.1, Expect = 0.019
CLONE0 vs CLONE8: Score = 21.9, Expect = 0.037
CLONE4 vs CLONE7: Score = 21.2, Expect = 0.071
CLONE5 vs CLONE9: Score = 20.8, Expect = 0.10
CLONE8 vs CLONE9: Score = 20.4, Expect = 0.12
CLONE1 vs CLONE2: Score = 19.6, Expect = 0.24
CLONE2 vs CLONE7: Score = 19.2, Expect = 0.32
CLONE0 vs CLONE3: Score = 18.9, Expect = 0.33
CLONE1 vs CLONE9: Score = 18.9, Expect = 0.38
CLONE1 vs CLONE5: Score = 18.5, Expect = 0.44
CLONE4 vs CLONE5: Score = 18.5, Expect = 0.49
CLONE3 vs CLONE7: Score = 18.5, Expect = 0.56
CLONE4 vs CLONE8: Score = 18.1, Expect = 0.61
CLONE2 vs CLONE4: Score = 18.1, Expect = 0.69
CLONE7 vs CLONE9: Score = 18.1, Expect = 0.72
CLONE3 vs CLONE8: Score = 17.3, Expect = 1.0
CLONE6 vs CLONE7: Score = 17.3, Expect = 1.0
CLONE6 vs CLONE9: Score = 17.3, Expect = 1.00
CLONE0 vs CLONE1: Score = 17.3, Expect = 1.1
CLONE0 vs CLONE5: Score = 17.3, Expect = 1.1
CLONE2 vs CLONE5: Score = 17.3, Expect = 1.1
CLONE2 vs CLONE8: Score = 17.3, Expect = 1.1
CLONE4 vs CLONE9: Score = 17.3, Expect = 1.1
CLONE2 vs CLONE9: Score = 17.3, Expect = 1.2
CLONE0 vs CLONE4: Score = 17.3, Expect = 1.3
CLONE1 vs CLONE7: Score = 16.9, Expect = 1.3
CLONE1 vs CLONE4: Score = 16.9, Expect = 1.4
CLONE0 vs CLONE6: Score = 16.9, Expect = 1.5
CLONE1 vs CLONE3: Score = 16.5, Expect = 1.9
CLONE1 vs CLONE6: Score = 16.5, Expect = 2.1
CLONE3 vs CLONE4: Score = 16.5, Expect = 2.3
CLONE3 vs CLONE9: Score = 16.2, Expect = 2.3
CLONE5 vs CLONE6: Score = 16.2, Expect = 2.4
CLONE1 vs CLONE8: Score = 16.2, Expect = 2.5
CLONE3 vs CLONE6: Score = 16.2, Expect = 2.5
CLONE2 vs CLONE6: Score = 16.2, Expect = 2.7
CLONE0 vs CLONE7: Score = 15.8, Expect = 3.8
CLONE2 vs CLONE3: Score = 15.4, Expect = 4.6
CLONE3 vs CLONE5: Score = 15.0, Expect = 5.5
CLONE5 vs CLONE8: Score = 15.0, Expect = 5.7
CLONE0 vs CLONE2: Score = 15.0, Expect = 5.8
CLONE6 vs CLONE8: Score = 15.0, Expect = 6.1
CLONE7 vs CLONE8: Score = 14.6, Expect = 8.6
CLONE0 vs CLONE9: Score = 14.2, Expect = 9.3
CLONE4 vs CLONE6: No hit
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;可以看到CLONE5和CLONE7的Score = 23.1、Expect = 0.019比对结果最好。&lt;/p&gt;

    &lt;p&gt;更进一步查看二者比对的blastp结果文件output/blastp_5_7：&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt; Score = 23.1 bits (48),  Expect = 0.019, Method: Compositional matrix adjust.
 Identities = 12/32 (38%), Positives = 18/32 (56%), Gaps = 0/32 (0%)
   
Query  256  SKQLEAPSNSSHIEVVSGRVSNLDYKGTNKRN  287
            ++ LE  S  S I  +SG + +L Y G  +RN
Sbjct  158  AQDLEVASQRSDINDLSGILEHLFYNGQMRRN  189
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;可以看到CLONE5的第256~287处序列SKQLEAPSNSSHIEVVSGRVSNLDYKGTNKRN，和CLONE7的第158~189处序列AQDLEVASQRSDINDLSGILEHLFYNGQMRRN的详细比对结果（打分、E值、一致性、相似率、缺失/插入率，以及具体哪部分序列match或mismatch）。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;hw2-练习题&quot;&gt;HW2 练习题&lt;/h2&gt;</content><author><name>Hanna Wang</name></author><category term="posts" /><category term="bioinformatics" /><category term="blog" /><summary type="html">HW2 必做题</summary></entry><entry><title type="html">与时代相互选择，极简所带来的无限可能</title><link href="https://hanna0911.github.io/posts/network-darpa/" rel="alternate" type="text/html" title="与时代相互选择，极简所带来的无限可能" /><published>2022-10-06T13:50:00+00:00</published><updated>2022-10-08T12:01:53+00:00</updated><id>https://hanna0911.github.io/posts/network-darpa</id><content type="html" xml:base="https://hanna0911.github.io/posts/network-darpa/">&lt;blockquote&gt;
  &lt;p&gt;读《DARPA 互联网协议的设计理念》有感&lt;/p&gt;

  &lt;p&gt;文献：David D. Clark. “The Design Philosophy of the DARPA Internet Protocols”, In: Proceedings of ACM SIGCOMM’88, Aug. 1988.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;论文中讲述了基于TCP/IP协议的DARPA互联网架构的设计理念，包括互联网所要实现的目标（主要目标：互联；二级目标：鲁棒、服务通用、网络通用、分布式管理、低成本高效益、互联便捷、资源可计量，优先级依次递减）和为了实现这些目标所选取的基本架构（分组交换、存储转发）。&lt;/p&gt;

&lt;p&gt;在阅读过程中，第一个让我比较有感触的点在于，DARPA设计之初是为了在战争时期服务于军方，预设的通信环境恶劣，因此将最高优先级目标设为鲁棒性（同时将资源计量放在最末），旨在不计代价地聚集资源来实现通信，因此选择了基于端到端原则、命运共享模式的无状态的分组交换技术；若是放在当下的商业环境中，计量计费、低成本高效益等目标肯定优先级会更靠前，设计出来的互联网架构则将截然不同。但即便这一互联网架构看似“过时”，却仍沿用至今、遍布全球，这与用户惯性密不可分。就如同现在我们从IPv4换到IPv6是一个艰难、漫长的过程一样，若要更改已经有了如此庞大体量的互联网架构，只会更加不切实际。因此如今我们所使用的互联网之所以是这般模样，一方面是源自于需求的技术选择，但另一不可忽视的方面是源自于时代选择的机遇性。&lt;/p&gt;

&lt;p&gt;当然，时代的选择是毕竟还是果，令这一架构成为行业标准的因还是在于其无限的可能性。这也是另一个让我深有感触的点，即网络的架构与实现的辩证性——越简单、限制越少的网络架构，其所具有的工程实现的可能性就丰富、多样。DARPA互联网架构正是如此，它不受限于各种工程实现的可靠性、时延、带宽等具体约束需求，从而造成庞大的体量而无法迁移到不同服务中；而是为了能在工程实现时满足更多服务，通过TCP提供可靠的数据流传输、IP提供可建立多种服务的数据报文协议，因此易于传输、对中继节点的依赖性大幅降低，这样网络结构本身就轻量、不具有冗余，多样的服务需求在工程实现时交付给端系统、网关中基于数据报文的特定算法即可，具有极强的拓展空间。&lt;/p&gt;

&lt;p&gt;总体而言，现今还在被广泛使用的互联网架构，还是终归要服务于当下时代、满足当下需求，而具体如何满足时代需求，更重要的还是如何具体的应用实现，发挥极简的网络架构所带来的互联网的无限可能。&lt;/p&gt;</content><author><name>Hanna Wang</name></author><category term="posts" /><category term="computer-science" /><category term="blog" /><summary type="html">读《DARPA 互联网协议的设计理念》有感 文献：David D. Clark. “The Design Philosophy of the DARPA Internet Protocols”, In: Proceedings of ACM SIGCOMM’88, Aug. 1988.</summary></entry><entry><title type="html">生信 Week 2 上机任务</title><link href="https://hanna0911.github.io/posts/bioinfo-class2/" rel="alternate" type="text/html" title="生信 Week 2 上机任务" /><published>2022-09-23T06:45:25+00:00</published><updated>2022-09-23T06:45:25+00:00</updated><id>https://hanna0911.github.io/posts/bioinfo-class2</id><content type="html" xml:base="https://hanna0911.github.io/posts/bioinfo-class2/">&lt;p&gt;写出一个bash脚本，可以使它自动读取一个文件夹（例如bash_homework/）的内容，将该文件夹下文件的名字输出到filenames.txt，子文件夹的名字输出到 dirname.txt。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;下载bash_homework.zip并解压。（该文件位于&lt;a href=&quot;&quot;&gt;该链接&lt;/a&gt;中&lt;strong&gt;Files needed by this Tutorial&lt;/strong&gt;中的清华云Bioinformatics Tutorial / Files路径下的相应文件夹中。）&lt;/p&gt;

  &lt;p&gt;将bash脚本，filename.txt，dirname.txt 写到同一个文件中上交。格式建议： word, pdf, txt.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;bash脚本：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;c&quot;&gt;#!/bin/bash&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;# 提示用户输入待查看文件夹的路径（绝对路径/相对路径）&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-n&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;Please input the path of the directory you want to check: &quot;&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;# 保存用户输入的文件夹路径到check_path中&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;read &lt;/span&gt;check_path

&lt;span class=&quot;c&quot;&gt;# 输出文件路径&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;output_file&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;filenames.txt&quot;&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;output_directory&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;dirname.txt&quot;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;item &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;check_path&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;/&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;do
    &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;item_name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;basename&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$item&lt;/span&gt;&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;# 去除目录文件夹前缀${check_path}/&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;# 若item是文件，则输出该文件名到filenames.txt中&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-f&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$item&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;then
        &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$item_name&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$output_file&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;# 若item是子文件夹，则输出该子文件夹的名字到dirname.txt中&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;elif&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-d&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$item&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;then
        &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$item_name&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$output_directory&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;fi 
done

&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;exit &lt;/span&gt;0
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;filename.txt：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;a.txt
a1.txt
b.filter_random.pl
b1.txt
bam_wig.sh
c.txt
c1.txt
chrom.size
d1.txt
dir.txt
e1.txt
f1.txt
human_geneExp.txt
if.sh
image
insitiue.txt
mouse_geneExp.txt
name.txt
number.sh
out.bw
random.sh
read.sh
test.sh
test.txt
test3.sh
test4.sh
wigToBigWig
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;dirname.txt：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;RBP_map
a-docker
app
backup
bin
biosoft
c1-RBPanno
datatable
db
download
e-annotation
exRNA
genome
git
highcharts
home
hub29
ibme
l-lwl
map2
mljs
module
mogproject
node_modules
perl5
postar.docker
postar2
postar_app
rout
script
script_backup
software
tcga
test
tmp
tmp_script
var
x-rbp
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>Hanna Wang</name></author><category term="posts" /><category term="bioinformatics" /><category term="blog" /><summary type="html">写出一个bash脚本，可以使它自动读取一个文件夹（例如bash_homework/）的内容，将该文件夹下文件的名字输出到filenames.txt，子文件夹的名字输出到 dirname.txt。</summary></entry><entry><title type="html">生信 Week 1 作业</title><link href="https://hanna0911.github.io/posts/bioinfo-hw1/" rel="alternate" type="text/html" title="生信 Week 1 作业" /><published>2022-09-17T16:32:40+00:00</published><updated>2022-09-17T18:58:54+00:00</updated><id>https://hanna0911.github.io/posts/bioinfo-hw1</id><content type="html" xml:base="https://hanna0911.github.io/posts/bioinfo-hw1/">&lt;blockquote&gt;
  &lt;p&gt;&lt;a href=&quot;https://book.ncrnalab.org/teaching/part-i.-basic-skills/2.linux/2.2.linux-practice-guide#homework&quot;&gt;PART I-2.Liunx-2.2.Practice Guide&lt;/a&gt;&lt;/p&gt;

  &lt;p&gt;提交word/md/txt/sh文件均可&lt;/p&gt;

  &lt;p&gt;第2，3题要求给出结果，并附上使用的命令&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;解释1.gtf文件中第4、5列代表什么，exon长度应该是$5-$4+1还是$5-$4？&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;第4列start代表基因组起始位置坐标（从1开始，闭区间），第5列end代表基因组终止位置坐标（从1开始，闭区间）。&lt;/p&gt;

    &lt;p&gt;exon的长度是$5-$4+1。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;列出1.gtf文件中 XI 号染色体上的后 10 个 CDS （按照每个CDS终止位置的基因组坐标进行sort）。&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;结果：&lt;/p&gt;

    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;c&quot;&gt;# 基因ID 终止位置坐标&lt;/span&gt;
YKR106W 663286
YKR105C 660464
YKR104W 657753
YKR103W 656733
YKR102W 649862
YKR101W 642501
YKR100C 639968
YKR099W 638283
YKR098C 635179
YKR097W 632798
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;命令：&lt;/p&gt;

    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;c&quot;&gt;#!/bin/bash&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;cat &lt;/span&gt;1.gtf | &lt;span class=&quot;nb&quot;&gt;awk&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'$1 == &quot;XI&quot; &amp;amp;&amp;amp; $3 == &quot;CDS&quot;'&lt;/span&gt; | &lt;span class=&quot;nb&quot;&gt;sort&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-k&lt;/span&gt; 5 &lt;span class=&quot;nt&quot;&gt;-nr&lt;/span&gt; | &lt;span class=&quot;nb&quot;&gt;awk&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'{split($10, x, &quot;;&quot;); name = x[1]; gsub(&quot;\&quot;&quot;, &quot;&quot;, name); print name, $5}'&lt;/span&gt; | &lt;span class=&quot;nb&quot;&gt;head&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-n&lt;/span&gt; 10
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;统计 IV 号染色体上各类 feature （1.gtf文件的第3列，有些注释文件中还应同时考虑第2列） 的数目，并按升序排列。&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;结果：&lt;/p&gt;

    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;c&quot;&gt;# 出现数目 feature类别&lt;/span&gt;
853 start_codon
853 stop_codon
886 gene
886 transcript
895 CDS
933 exon
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;命令：&lt;/p&gt;

    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;c&quot;&gt;#!/bin/bash&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;cat &lt;/span&gt;1.gtf |awk &lt;span class=&quot;s1&quot;&gt;'$1 == &quot;IV&quot; {print $3}'&lt;/span&gt;| &lt;span class=&quot;nb&quot;&gt;sort&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-n&lt;/span&gt; | &lt;span class=&quot;nb&quot;&gt;uniq&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-c&lt;/span&gt; | &lt;span class=&quot;nb&quot;&gt;sort&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-k&lt;/span&gt; 1 &lt;span class=&quot;nt&quot;&gt;-n&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;</content><author><name>Hanna Wang</name></author><category term="posts" /><category term="bioinformatics" /><category term="blog" /><summary type="html">PART I-2.Liunx-2.2.Practice Guide 提交word/md/txt/sh文件均可 第2，3题要求给出结果，并附上使用的命令</summary></entry><entry><title type="html">计组实验1：汇编语言与监控程序</title><link href="https://hanna0911.github.io/posts/riscv-homework/" rel="alternate" type="text/html" title="计组实验1：汇编语言与监控程序" /><published>2022-09-17T14:04:07+00:00</published><updated>2022-10-08T12:01:53+00:00</updated><id>https://hanna0911.github.io/posts/riscv-homework</id><content type="html" xml:base="https://hanna0911.github.io/posts/riscv-homework/">&lt;h2 id=&quot;实验报告&quot;&gt;实验报告&lt;/h2&gt;

&lt;h3 id=&quot;实验1risc-v监控程序与term命令&quot;&gt;实验1：RISC-V监控程序与Term命令&lt;/h3&gt;

&lt;p&gt;在模拟器中运行 RISC-V 监控程序的基本步骤如下：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;启动监控程序&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/assets/Screen Shot 2022-09-14 at 2.07.46 PM.png&quot; alt=&quot;Screen Shot 2022-09-14 at 2.07.46 PM&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;通过终端连接监控程序&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/assets/Screen Shot 2022-09-14 at 2.08.16 PM.png&quot; alt=&quot;Screen Shot 2022-09-14 at 2.08.16 PM&quot; style=&quot;zoom:33%;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Term 中几个命令的使用方法（以下对每个命令的介绍均来自&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;supervisor-rv/&lt;/code&gt;文件夹中的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;README.md&lt;/code&gt;文件）：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;R&lt;/code&gt;：按照 x1 至 x31 的顺序返回用户程序寄存器值。&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/assets/Screen Shot 2022-09-14 at 2.11.48 PM.png&quot; alt=&quot;Screen Shot 2022-09-14 at 2.11.48 PM&quot; style=&quot;zoom: 33%;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;D&lt;/code&gt;：显示从指定地址开始的一段内存区域中的数据。&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/assets/Screen Shot 2022-09-14 at 2.12.15 PM.png&quot; alt=&quot;Screen Shot 2022-09-14 at 2.12.15 PM&quot; style=&quot;zoom:33%;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;A&lt;/code&gt;：用户输入汇编指令，并放置到指定地址上&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/assets/Screen Shot 2022-09-14 at 2.14.14 PM.png&quot; alt=&quot;Screen Shot 2022-09-14 at 2.14.14 PM&quot; style=&quot;zoom:33%;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;F&lt;/code&gt;：从文件读入汇编指令并放置到指定地址上，格式与 A 命令相同。&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/assets/Screen Shot 2022-09-14 at 2.16.40 PM.png&quot; alt=&quot;Screen Shot 2022-09-14 at 2.16.40 PM&quot; style=&quot;zoom:33%;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;U&lt;/code&gt;：从指定地址读取一定长度的数据，并显示反汇编结果。&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/assets/Screen Shot 2022-09-14 at 2.17.30 PM.png&quot; alt=&quot;Screen Shot 2022-09-14 at 2.17.30 PM&quot; style=&quot;zoom: 33%;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;G&lt;/code&gt;：执行指定地址的用户程序。&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/assets/Screen Shot 2022-09-14 at 2.17.54 PM.png&quot; alt=&quot;Screen Shot 2022-09-14 at 2.17.54 PM&quot; style=&quot;zoom:33%;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;T&lt;/code&gt;：查看页表内容，仅在启用页表时有效。&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/assets/Screen Shot 2022-09-14 at 2.18.30 PM.png&quot; alt=&quot;Screen Shot 2022-09-14 at 2.18.30 PM&quot; style=&quot;zoom:33%;&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;加上flag&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;EN_PAGING=y&lt;/code&gt;来启动监控程序，以启用页表（以下是部分页表内容截图）：&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/assets/Screen Shot 2022-09-15 at 10.19.30 AM.png&quot; alt=&quot;Screen Shot 2022-09-15 at 10.19.30 AM&quot; style=&quot;zoom:33%;&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/assets/Screen Shot 2022-09-15 at 10.18.38 AM.png&quot; alt=&quot;Screen Shot 2022-09-15 at 10.18.38 AM&quot; style=&quot;zoom:33%;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Q&lt;/code&gt;：退出 Term。&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/assets/Screen Shot 2022-09-14 at 2.19.51 PM.png&quot; alt=&quot;Screen Shot 2022-09-14 at 2.19.51 PM&quot; style=&quot;zoom:33%;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;实验2求前10个fibonacci数&quot;&gt;实验2：求前10个Fibonacci数&lt;/h3&gt;

&lt;p&gt;我的代码参考了&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;asmcode/&lt;/code&gt;文件夹中&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sum.s&lt;/code&gt;与&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fib-mem.s&lt;/code&gt;代码。其中&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sum.s&lt;/code&gt;中采用循环的方式计算了$1 + 2 + … + 10$，在我的代码中也参考了这一循环&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;loop&lt;/code&gt;的书写方式，通过一个计数器&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;t3&lt;/code&gt;来控制是否完成了&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;t4 = 10&lt;/code&gt;次的计算循环（事实上只需要进行8次循环即可，因为前2项Fib数是既定已给出的，无需计算）。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fib-mem.s&lt;/code&gt;中比较关键的则是Fib数递推的步骤：根据递推式计算下一个Fib数&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;add  t2, t0, t1  # t2 = t0+t1&lt;/code&gt;，以及为下一轮递推做准备&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ori  t0, t1, 0x0  # t0 = t1&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ori  t1, t2, 0x0  # t1 = t2&lt;/code&gt;，在我的代码中也参考了这一书写规范来进行Fib数的递推计算。&lt;/p&gt;

&lt;p&gt;代码的总体思路分为以下几步：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;初始化加数（第一个Fib数&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;t0&lt;/code&gt;，第二个Fib数&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;t1&lt;/code&gt;），并设置好计数器相关变量（已计算次数&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;t3&lt;/code&gt;、总共计算次数&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;t4&lt;/code&gt;）、待写入地址&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;t5&lt;/code&gt;；&lt;/li&gt;
  &lt;li&gt;将前2个已知Fib数写入当前地址，并更新下一待写入地址；&lt;/li&gt;
  &lt;li&gt;通过循环，以计算Fib递推式计算下一个Fib数&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;t2 = t0 + t1&lt;/code&gt;，并在进入下一轮循环之前更新计算次数&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;t3&lt;/code&gt;、待写入地址&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;t5&lt;/code&gt;、新一轮递推的加数&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;t0&lt;/code&gt;,&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt; t1&lt;/code&gt;，其中循环的终止条件为&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;t3 == t4&lt;/code&gt;（即完成了&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;t4&lt;/code&gt;次计算）；&lt;/li&gt;
  &lt;li&gt;达到循环的终止条件（或不再满足循环的执行条件&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;t3 != t4&lt;/code&gt;），返回，程序终止。&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;    .global _start
    .text

_start:

    li t0, 0x1   &lt;span class=&quot;c&quot;&gt;# t0 = 1，加数（第1个Fib数）&lt;/span&gt;
    li t1, 0x1   &lt;span class=&quot;c&quot;&gt;# t1 = 1，加数（第2个Fib数）&lt;/span&gt;
    li t3, 0x2   &lt;span class=&quot;c&quot;&gt;# 已计算次数，用于计数（前2项已给出）&lt;/span&gt;
    li t4, 0xA   &lt;span class=&quot;c&quot;&gt;# t4 = 10，一共需计算前10个Fib数&lt;/span&gt;
    li t5, 0x80400000  &lt;span class=&quot;c&quot;&gt;# 待写入的地址&lt;/span&gt;

    sw  t0, 0x0&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;t5&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;  &lt;span class=&quot;c&quot;&gt;# 将第1个Fib数写入地址&lt;/span&gt;
    sw  t1, 0x4&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;t5&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;  &lt;span class=&quot;c&quot;&gt;# 将第2个Fib数写入地址&lt;/span&gt;
    addi t5, t5, 0x8  &lt;span class=&quot;c&quot;&gt;# 待写入地址自增&lt;/span&gt;

loop:

    add t2, t0, t1   &lt;span class=&quot;c&quot;&gt;# t2 = t0 + t1，Fib数递推式&lt;/span&gt;
    addi t3, t3, 0x1  &lt;span class=&quot;c&quot;&gt;# t3++，已计算次数自增&lt;/span&gt;
    sw  t2, 0x0&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;t5&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;  &lt;span class=&quot;c&quot;&gt;# 将第t3个Fib数写入地址&lt;/span&gt;
    addi t5, t5, 0x4  &lt;span class=&quot;c&quot;&gt;# 待写入地址自增&lt;/span&gt;

    ori t0, t1, 0x0  &lt;span class=&quot;c&quot;&gt;# t0 = t1，为新一轮Fib数递推计算做准备&lt;/span&gt;
    ori t1, t2, 0x0  &lt;span class=&quot;c&quot;&gt;# t1 = t2，同上&lt;/span&gt;
    bne t3, t4, loop &lt;span class=&quot;c&quot;&gt;# 若没算完10个Fib数（t3 != t4），则通过loop继续计算&lt;/span&gt;
    nop
    jr ra            &lt;span class=&quot;c&quot;&gt;# 否则（t3 == t4）返回，程序终止&lt;/span&gt;
    nop
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;supervisor-rv/kernel/&lt;/code&gt;目录下执行&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;make sim&lt;/code&gt;启动监控程序，并在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;supervisor-rv/term/&lt;/code&gt;目录下执行&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;python3 term.py -t 127.0.0.1:6666&lt;/code&gt;通过终端连接监控程序，并用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;gt;&amp;gt; F&lt;/code&gt;命令在监控程序中运行以上代码；通过&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;gt;&amp;gt; D&lt;/code&gt;命令查看内存地址&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0x80400000~0x80400024&lt;/code&gt;，结果如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/Screen Shot 2022-09-14 at 11.32.32 AM.png&quot; alt=&quot;Screen Shot 2022-09-14 at 11.32.32 AM&quot; style=&quot;zoom: 50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;验证了存入起始地址为&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0x80400000&lt;/code&gt;的10个字中的数（16进制），与前10个Fibonacci数$1, 1, 2, 3, 5, 8, 13, 21, 34, 55$（十进制）一一对应，结果正确。&lt;/p&gt;

&lt;h3 id=&quot;实验3输出ascii可见字符&quot;&gt;实验3：输出ASCII可见字符&lt;/h3&gt;

&lt;p&gt;我的代码参考了实验说明文档中提供的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;WRITE_SERIAL&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.TESTW&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.WSERIAL&lt;/code&gt;函数，以实现从终端输出字符。至于输出由&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0x21&lt;/code&gt;~&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0x7E&lt;/code&gt;共94个ASCII可见字符，采用循环的方式（94次循环）来进行输出，其中&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a0&lt;/code&gt;寄存器所存储的既是输出的对象（ASCII可见字符的十六进制编码）、又是计数器（由&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0x21&lt;/code&gt;开始计数到&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0x7E&lt;/code&gt;）。&lt;/p&gt;

&lt;p&gt;代码的总体思路分为以下几步：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;初始化循环开始字符&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a0&lt;/code&gt;、结束字符&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;t2&lt;/code&gt;，注意因为执行循环的边界条件判断为“不等”（&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bne  a0, t2, WRITE_SERIAL  # a0 != t2 &lt;/code&gt; ）而非“小于等于”（&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a0 &amp;lt;= t2&lt;/code&gt;），因此结束字符&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;t2&lt;/code&gt;需要额外加一；&lt;/li&gt;
  &lt;li&gt;通过循环，向终端（&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0x10000000&lt;/code&gt;）输出&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a0&lt;/code&gt;寄存器中的最低字节，并在进入下一轮循环前更新&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a0&lt;/code&gt;的值（&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a0++&lt;/code&gt;，切换到下一顺位ASCII可见字符），其中循环的终止条件为&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a0 == t2&lt;/code&gt;（即完成了由&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0x21&lt;/code&gt;~&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0x7E&lt;/code&gt;所有ASCII可见字符的输出）；&lt;/li&gt;
  &lt;li&gt;达到循环的终止条件（或不再满足循环的执行条件&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a0 != t2&lt;/code&gt;），返回，程序终止。&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;.section .text
.globl _start

_start:
    li  a0, 0x21      &lt;span class=&quot;c&quot;&gt;# 循环开始字符&lt;/span&gt;
    li  t2, 0x7E      &lt;span class=&quot;c&quot;&gt;# 循环结束字符&lt;/span&gt;
    addi t2, t2, 0x1  &lt;span class=&quot;c&quot;&gt;# .WSERIAL处bne边界条件&lt;/span&gt;

WRITE_SERIAL:
    &lt;span class=&quot;c&quot;&gt;# 串口地址是 0x10000000&lt;/span&gt;
    li t0, 0x10000000

    &lt;span class=&quot;c&quot;&gt;# 轮询串口状态（0x10000005）&lt;/span&gt;

.TESTW:
    lb t1, 5&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;t0&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;# 判断是否可写&lt;/span&gt;
    andi t1, t1, 0x20
    beq t1, zero, .TESTW

.WSERIAL:
    &lt;span class=&quot;c&quot;&gt;# 向终端（0x10000000）输出 a0 寄存器中的最低字节&lt;/span&gt;
    sb a0, 0&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;t0&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;

    addi a0, a0, 0x1          &lt;span class=&quot;c&quot;&gt;# a0++，切换到下一字符以输出&lt;/span&gt;
    bne a0, t2, WRITE_SERIAL  &lt;span class=&quot;c&quot;&gt;# 若未达到边界条件（a0 != t2）则继续输出ascii字符&lt;/span&gt;
    nop
    jr ra                     &lt;span class=&quot;c&quot;&gt;# 否则（a0 == t2）返回，终止程序&lt;/span&gt;
    nop
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;同样启动监控程序，并通过终端连接监控程序，在监控程序中运行以上代码，得到结果：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/Screen Shot 2022-09-15 at 2.08.50 PM.png&quot; alt=&quot;Screen Shot 2022-09-15 at 2.08.50 PM&quot; /&gt;&lt;/p&gt;

&lt;p&gt;成功向终端输出了ASCII 可见字符：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;!&quot;#$%&amp;amp;'()*+,-./0123456789:;&amp;lt;=&amp;gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;实验4求第60个fibonacci数&quot;&gt;实验4：求第60个Fibonacci数&lt;/h3&gt;

&lt;p&gt;与实验2基本一致，但由于第60个Fibonacci数已经超过了32位整型，因此需要在实验2的基础上作出一些修改，主要区别如下：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;原先存储Fib数的3个32位寄存器&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;t0&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;t1&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;t2&lt;/code&gt;，改由6个32位寄存器存储，其中每个64位的整数由2个32位寄存器储存，即&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;{a3, a2}&lt;/code&gt;储存第一个Fib数、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;{a5, a4}&lt;/code&gt;储存第二个Fib数、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;{a1, a0}&lt;/code&gt;用来储存由Fib递推式计算得到的下一个Fib数（高位为&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a3&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a5&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a1&lt;/code&gt;，低位为&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a2&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a4&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a0&lt;/code&gt;）；&lt;/li&gt;
  &lt;li&gt;计数器相关变量已计算次数&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;t3&lt;/code&gt;保持一致，而总共计算次数&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;t4&lt;/code&gt;由10（&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0xA&lt;/code&gt;）改为60（&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0x3C&lt;/code&gt;）；&lt;/li&gt;
  &lt;li&gt;根据Fib递推式进行的加法运算，由原来的32位整型加法改为64位整型加法，此处参考了实验说明文档中提供的大位宽数据加法的实现方法；&lt;/li&gt;
  &lt;li&gt;为新一轮Fib数递推计算做准备，赋值时注意要把两个Fib加数的高位、低位寄存器都赋值（因此由原本的两个语句变为四个语句，每个加数各有两个待更新的寄存器需要被赋值）；&lt;/li&gt;
  &lt;li&gt;只需将第60个Fib数写入制定内存地址即可，因此不再需要每次循环都写入一次地址，而只需要在退出循环之后，执行一次第60个Fib数&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;{a1, a0}&lt;/code&gt;的写入即可（注意低位&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a0&lt;/code&gt;写入&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0x80400000&lt;/code&gt;、高位&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a1&lt;/code&gt;写入&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0x80400004&lt;/code&gt;）。&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;    .global _start
    .text
    
_start:

    li a1, 0x0   &lt;span class=&quot;c&quot;&gt;# {a1, a0} = {0, 0}，初始化Fib数和&lt;/span&gt;
    li a0, 0x0
    li a3, 0x0   &lt;span class=&quot;c&quot;&gt;# {a3, a2} = {0, 1}，初始化Fib数加数（第1个Fib数为1）&lt;/span&gt;
    li a2, 0x1
    li a5, 0x0   &lt;span class=&quot;c&quot;&gt;# {a5, a4} = {0, 1}，初始化Fib数加数（第2个Fib数为1）&lt;/span&gt;
    li a4, 0x1

    li t3, 0x2   &lt;span class=&quot;c&quot;&gt;# 已计算次数，用于计数（前2项已给出）&lt;/span&gt;
    li t4, 0x3C  &lt;span class=&quot;c&quot;&gt;# t4 = 60，需计算到第60个Fib数&lt;/span&gt;
    li t5, 0x80400000  &lt;span class=&quot;c&quot;&gt;# 待写入的地址&lt;/span&gt;

loop:
    &lt;span class=&quot;c&quot;&gt;# {a3, a2} 即把低位保存在 a2，高位保存在 a3 的 64 位整数&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;# {a3, a2} + {a5, a4} = {a1, a0}&lt;/span&gt;
    add a0, a2, a4
    sltu a2, a0, a2
    add a1, a3, a5
    add a1, a2, a1

    addi t3, t3, 0x1  &lt;span class=&quot;c&quot;&gt;# t3++，已计算次数自增&lt;/span&gt;

    ori a3, a5, 0x0   &lt;span class=&quot;c&quot;&gt;# {a3, a2} = {a5, a4}，为新一轮Fib数递推计算做准备&lt;/span&gt;
    ori a2, a4, 0x0
    ori a5, a1, 0x0   &lt;span class=&quot;c&quot;&gt;# {a5, a4} = {a1, a0}，同上&lt;/span&gt;
    ori a4, a0, 0x0

    bne t3, t4, loop  &lt;span class=&quot;c&quot;&gt;# 若没算到第60个Fib数（t3 != t4），则通过loop继续计算&lt;/span&gt;
    nop

    sw a0, 0x0&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;t5&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;    &lt;span class=&quot;c&quot;&gt;# 否则（t3 == t4）将第60个Fib数{a1, a0}写入地址&lt;/span&gt;
    sw a1, 0x4&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;t5&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;

    jr ra             &lt;span class=&quot;c&quot;&gt;# 返回，程序终止&lt;/span&gt;
    nop
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;同样启动监控程序，并通过终端连接监控程序，在监控程序中运行以上代码（方法与实验2、3均一致，此处省略），得到结果：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/Screen Shot 2022-09-14 at 1.03.52 PM.png&quot; alt=&quot;Screen Shot 2022-09-14 at 1.03.52 PM&quot; style=&quot;zoom: 50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;存入内存的结果&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0x1686c8312d0&lt;/code&gt;（十六进制）与第60个Fib数1548008755920（十进制）相同，结果正确。&lt;/p&gt;

&lt;h2 id=&quot;代码分析报告&quot;&gt;代码分析报告&lt;/h2&gt;

&lt;p&gt;虽然在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;supervisor-rv/README.md&lt;/code&gt;文件中的“介绍”章节中写到“&lt;strong&gt;监控程序&lt;/strong&gt;分为两个部分，&lt;strong&gt;Kernel&lt;/strong&gt;和&lt;strong&gt;Term&lt;/strong&gt;”，但鉴于实验说明文档中的要求是“撰写&lt;strong&gt;监控程序&lt;/strong&gt;以及&lt;strong&gt;终端程序&lt;/strong&gt;的代码分析报告”，以下均以实验说明文档中的说法为准，即&lt;strong&gt;监控程序&lt;/strong&gt;代表&lt;strong&gt;Kernel&lt;/strong&gt;、&lt;strong&gt;终端程序&lt;/strong&gt;代表&lt;strong&gt;Term&lt;/strong&gt;，而&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;README.md&lt;/code&gt;文档中的“监控程序Supervisor”本质为一个简化的“&lt;strong&gt;操作系统&lt;/strong&gt;”（即操作系统Supervisor分为监控程序Kernel和终端程序Term两个部分）。&lt;/p&gt;

&lt;p&gt;在本次实验中，监控程序Kernel被运行在模拟环境QEMU中（QEMU模拟了RISC-V指令与系统，在后续实验中模拟环境QEMU将被物理实验平台替代），而我们需要通过终端程序Term与模拟环境QEMU中的监控程序Kernel进行交互，具体交互流程将在后续&lt;a href=&quot;#1&quot;&gt;交互流程&lt;/a&gt;一节中阐释。以下将先分别给出监控程序Kernel与终端程序Term的代码分析。&lt;/p&gt;

&lt;h3 id=&quot;监控程序kernel&quot;&gt;监控程序Kernel&lt;/h3&gt;

&lt;p&gt;监控程序Kernel的代码在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;supervisor-rv/kernal/&lt;/code&gt;文件夹中：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;.
├── Makefile（编译规则）
├── debug（调试指令）
├── include（头文件）
│   ├── common.h（基本信息如使用32位或64位架构使用的访存指令与地址位数、用户栈初始化、各信号相关常量等）
│   ├── exception.h（异常相关的常量）
│   └── serial.h（串口相关的常量）
├── kern（监控程序Kernel核心代码！！！）
│   ├── evec.S（监控程序入口点）
│   ├── init.S（监控程序初始化）
│   ├── kernel32.ld（32位RISC-V的链接文件）
│   ├── kernel64.ld（64位RISV-V的链接文件）
│   ├── shell.S（监控程序的交互功能实现）
│   ├── test.S（监控程序的性能测试程序）
│   ├── trap.S（监控程序中涉及中断相关代码）
│   └── utils.S（通过串口进行读、写数据相关代码）
├── kernel.asm（make编译Kernel程序后生成的文件）
├── kernel.bin（make编译Kernel程序后生成的文件）
├── kernel.elf（make编译Kernel程序后生成的文件）
└── obj/（内含make编译Kernel程序后生成的文件）
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;核心代码均在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kern/&lt;/code&gt;文件夹中，其中涉及到本次实验基础版本Kernel的文件为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;evec.S&lt;/code&gt; 、 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;init.S&lt;/code&gt; 、 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;shell.S&lt;/code&gt; 、 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;utils.S&lt;/code&gt; 这4个文件。程序的结构为：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-mermaid&quot;&gt;graph TD

		subgraph evec.S
				subgraph INITLOCATE
						A[Kernel入口, 跳转到init.S: START]
				end
		end
		A --&amp;gt; C
		subgraph init.S
				subgraph START
            C[清空BSS段, 设置内核栈+用户栈+用户态程序sp和fp寄存器] --&amp;gt; D[配置串口等]
            D --&amp;gt; D1[配置中断帧]
				end
				subgraph WELCOME
						D1 --&amp;gt; D2[装入启动信息并打印]
						D3[跳转到shell.S: SHELL, 开始交互]
						
				end
		end
		
		D3 --&amp;gt; E
		
		subgraph utils.S
				subgraph WRITE_SERIAL_STRING
						D2 --&amp;gt; H[写字符串: 将a0地址开始处的字符串写入串口]
						H --&amp;gt; H1[调用串口写函数]	
						G[打印循环至 0 结束符]
				end
				
				subgraph WRITE_SERIAL
						H1 --&amp;gt; H2[写串口: 将a0的低八位写入串口]
						H2 --&amp;gt; H3[检测验证: 截取并查看串口状态的写状态位]
						H3 --&amp;gt;|非零可写, 进入写|H3_1[写入寄存器a0中的值]
						H3 --&amp;gt;|为零不可写, 忙等待|H3
						H3_1 --&amp;gt; G
						G --&amp;gt; D3
				end
				
								
				subgraph READ_SERIAL
						F[读串口: 将读到的数据写入a0低八位]
						F --&amp;gt; F1[检测验证: 截取并查看串口状态的读状态位]
						F1 --&amp;gt;|非零可读, 进入读|F1_1[将串口中的值读取到寄存器a0]
						F1 --&amp;gt;|为零不可读, 忙等待|F1
				end
		end
		
				
		subgraph shell.S
				subgraph SHELL
						E[调用串口读函数, 读取操作符] --&amp;gt; F
						F1_1 --&amp;gt; I[根据操作符进行不同的操作]
						
						I --&amp;gt;|'R'|OP_R
						I --&amp;gt;|'D'|OP_D
						I --&amp;gt;|'A'|OP_A
						I --&amp;gt;|'G'|OP_G
						I --&amp;gt;|'T'|OP_T
						I --&amp;gt;|其他, 主要指'W'|OP_OTHER
						
						subgraph .OP_R
								OP_R[打印用户空间寄存器]
						end
						
						subgraph .OP_D
								OP_D[打印内存num个字节]
						end
						
						subgraph .OP_A
								OP_A[写入内存num字节, num为4的倍数]
						end
						
						subgraph .OP_G
								OP_G[跳转到用户程序执行]
						end
						
						subgraph .OP_T
								OP_T[打印页表] 
						end
						
						subgraph OTHER[错误反馈]
								OP_OTHER[把XLEN写给term] 
						end
						
						OP_R --&amp;gt; E
						OP_D --&amp;gt; E
						OP_A --&amp;gt; E
						OP_G --&amp;gt; E
						OP_T --&amp;gt; E
						OP_OTHER --&amp;gt; E
						
				end
		end		
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由于&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;shell.S&lt;/code&gt;中的具体操作（&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;R&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;D&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;A&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;G&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;T&lt;/code&gt;）繁多，在上图中不一一分析具体实现方法，只取比较核心的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;G&lt;/code&gt;运行用户代码操作做详细分析，其代码结构如下（所有的循环&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;i = 0, 1, 2, 3&lt;/code&gt;均是为了报告中书写方便，在实际代码中采用了直接书写四次代码实现）：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-mermaid&quot;&gt;graph TD
		subgraph shell.S
				subgraph .OP_G
						OP_G1[获取用户程序地址]
						OP_G2[从a0保存用户地址到s10]
						OP_G2 --&amp;gt; OP_G3[写开始计时信号SIG_TIMERSET到串口, 通知Term开始运行]
						OP_G4[定位用户空间寄存器备份地址] --&amp;gt; OP_G5[恢复用户程序调用前的寄存器数据]
						OP_G5 --&amp;gt; OP_G6[重新获得当前监控程序栈顶指针]
						OP_G6 --&amp;gt; OP_G7[写停止计时信号SIG_TIMETOKEN到串口, 通知Term结束计时, 调用WRITE_SERIAL过程与前述写SIG_TIMERSET一致, 此处省略]
				end
		end
		
		OP_G1 --&amp;gt; READ1
		OP_G3 --&amp;gt; WRITE
		
		subgraph utils.S
				subgraph READ_SERIAL_XLEN
						READ1[调用READ_SERIAL_WORD函数]
				end
				
				READ1 --&amp;gt; READ2
				
				subgraph READ_SERIAL_WORD
						READ2[保存ra, s0-s3]
						READ4[结果存入si, i++]
						READ5[截取s0-s3的低8位] --&amp;gt;|第i次, i=0,1,2,3|READ6[存si的高8位到a0中, 再左移8位, i++]
						READ6 --&amp;gt;|i&amp;lt;4|READ6
						READ6 --&amp;gt;|i&amp;gt;=4|READ7[通过ra保存的返回地址返回]
				end
				
				READ2 --&amp;gt;|调用第i次, i=0,1,2,3|READ3
				
				subgraph READ_SERIAL
						READ3[读串口获得8位数据]
				end
				
				READ3 --&amp;gt; READ4
				READ4 --&amp;gt;|i&amp;lt;4|READ3
				READ4 --&amp;gt;|i&amp;gt;=4|READ5
				READ7 --&amp;gt; OP_G2
				
				subgraph WRITE_SERIAL
						WRITE[检测验证+写串口, 同前述过程, 此处省略]
				end
				
				WRITE --&amp;gt; OP_G4
				
		end
		
		
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;终端程序term&quot;&gt;终端程序Term&lt;/h3&gt;

&lt;p&gt;终端程序的代码在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;supervisor-rv/term/term.py&lt;/code&gt;文件中，程序的结构为：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-mermaid&quot;&gt;graph TD
		subgraph main
				main2[设置命令行参数] 
				main3[初始化失败, 程序终止]
				main4[初始化成功, 进入Main函数]
		end
		
		main2 --&amp;gt;|检测tcp|TCP0.5
		main4 --&amp;gt; Main1
		
		subgraph InitializeTCP
				TCP0[创建tcp_wrapper类的服务器ser]--&amp;gt;TCP0.5[连接kernel, 设置inp, outp]
		end
		
		TCP0.5 --&amp;gt; TCP1
		
		subgraph tcp_wrapper
				subgraph connect
						TCP1[通过python的stdlib中的socket模块connect函数, 连接TCP服务器kernel的host+port]
				end
				
				subgraph read
						TCP_read[通过stdlib中的socket模块recv函数, 8位8位读取串口数据]
				end
				
				subgraph write
						TCP_write[通过stdlib中的socket模块send函数, 8位8位写入串口数据]
				end
		end
		
		TCP1 --&amp;gt;|连接成功|main3
    TCP1 --&amp;gt;|连接失败|main4
		
		Main0 --&amp;gt; TCP_read
		TCP_read --&amp;gt; Main1
		subgraph Main
				Main0[通过inp.read读取串口, 获得kernel发来的欢迎信息与xlen信息]
				Main1[输出, 并进入MainLoop函数]
		end
		
		Main1 --&amp;gt; ML1
		subgraph Mainloop
				ML1[根据用户在命令行中的指令cmd, 执行不同操作]
				
        ML1--&amp;gt;|'A'|A
        ML1--&amp;gt;|'F'|F
        ML1--&amp;gt;|'R'|R
        ML1--&amp;gt;|'D'|D
        ML1--&amp;gt;|'U'|U
        ML1--&amp;gt;|'G'|G
        ML1--&amp;gt;|'T'|T
        ML1--&amp;gt;|'Q'|Q
        subgraph run_A
            A[用户输入汇编指令, 并放置到指定地址上]
        end

        subgraph run_F
            F[从文件读入汇编指令并放置到指定地址上]
        end

        subgraph run_R
            R[返回用户程序寄存器值]
        end

        subgraph run_D
            D[显示从指定地址开始的一段内存区域中的数据]
        end

        subgraph run_U
            U[从指定地址读取一定长度的数据, 并显示反汇编结果]
        end

        subgraph run_G
            G[执行指定地址的用户程序]
        end

        subgraph run_T
            T[查看页表内容, 仅在启用页表时有效]
        end

        Q[退出Term]
        
        A--&amp;gt;ML2
        F--&amp;gt;ML2
        R--&amp;gt;ML2
        D--&amp;gt;ML2
        U--&amp;gt;ML2
        G--&amp;gt;ML2
        T--&amp;gt;ML2
        
        ML2[通过outp.write写入串口, 通知kernel执行该命令]--&amp;gt;TCP_write
        TCP_write --&amp;gt; ML1
		end
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;交互流程&quot;&gt;交互流程&lt;a id=&quot;1&quot;&gt;&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;Kernel和Term通过串口进行交互，即用户在Term中输入的命令、代码在经过 Term 处理后通过串口传输给 Kernel，而Kernel需要输出的信息也会通过串口传输到Term并展示给用户。在这里是使用QEMU模拟串口，其地址如&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;README.md&lt;/code&gt;文件所描述的：&lt;/p&gt;

&lt;blockquote&gt;

  &lt;p&gt;设置了一个内存以外的地址区域，用于串口收发。串口控制器按照 &lt;a href=&quot;https://www.lammertbies.nl/comm/info/serial-uart&quot;&gt;16550 UART 的寄存器&lt;/a&gt; 的子集实现，访问的代码位于 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kern/utils.S&lt;/code&gt; ，其部分数据格式为：&lt;/p&gt;

  &lt;table&gt;
    &lt;thead&gt;
      &lt;tr&gt;
        &lt;th&gt;地址&lt;/th&gt;
        &lt;th&gt;位&lt;/th&gt;
        &lt;th&gt;说明&lt;/th&gt;
      &lt;/tr&gt;
    &lt;/thead&gt;
    &lt;tbody&gt;
      &lt;tr&gt;
        &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;COM1&lt;/code&gt; = 0x10000000&lt;/td&gt;
        &lt;td&gt;[7:0]&lt;/td&gt;
        &lt;td&gt;串口数据，读、写地址分别表示串口接收、发送一个字节&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
        &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;COM1 + COM_LSR_OFFSET&lt;/code&gt; = 0x10000005&lt;/td&gt;
        &lt;td&gt;[5]&lt;/td&gt;
        &lt;td&gt;只读，为1时表示串口空闲，可发送数据&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
        &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;COM1 + COM_LSR_OFFSET&lt;/code&gt; = 0x10000005&lt;/td&gt;
        &lt;td&gt;[0]&lt;/td&gt;
        &lt;td&gt;只读，为1时表示串口收到数据&lt;/td&gt;
      &lt;/tr&gt;
    &lt;/tbody&gt;
  &lt;/table&gt;

&lt;/blockquote&gt;

&lt;p&gt;意思是不论是Kernel要读写数据（从/给Term读/写），还是Term要读写数据（从/给Kernel读/写），二者均需要在判断&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0x10000005&lt;/code&gt;地址处的相关检验位（可写位是第&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;5&lt;/code&gt;位，可读位是第&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0&lt;/code&gt;位）为1时，从&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0x10000000&lt;/code&gt;读/写8位的数据。一个重要的例子是，在前面针对监控程序Kernel的代码分析中，分析过的Term向Kernel发送用户代码的32位地址数据时（Term写、Kernel读），二者均需在判断可写/读时每次仅进行8位的数据交互，共4次，Kernel读到这4个8位的数据还需通过依次放入目标寄存器再左移的方法复原32位数据，实现完整的32位地址数据交互。&lt;/p&gt;

&lt;p&gt;在Kernel中交互主要的代码块在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;utils.S&lt;/code&gt;中，包含向串口写入数据的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;WRITE_SERIAL&lt;/code&gt; 、 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;WRITE_SERIAL_WORD&lt;/code&gt; 、 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;WRITE_SERIAL_XLEN&lt;/code&gt; 、 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;WRITE_SERIAL_STRING&lt;/code&gt; 函数，以及从串口读入数据的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;READ_SERIAL&lt;/code&gt; 、 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;READ_SERIAL_WORD&lt;/code&gt; 、 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;READ_SERIAL_XLEN&lt;/code&gt; 函数。其中 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;WRITE_SERIAL_WORD&lt;/code&gt; 、 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;WRITE_SERIAL_XLEN&lt;/code&gt; 、 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;WRITE_SERIAL_STRING&lt;/code&gt; 均是基于 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;WRITE_SERIAL&lt;/code&gt; 函数（内部根据写出的数据大小，选择调用对应次数的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;WRITE_SERIAL&lt;/code&gt; 函数），&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;READ_SERIAL_WORD&lt;/code&gt; 、 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;READ_SERIAL_XLEN&lt;/code&gt; 均是基于 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;READ_SERIAL&lt;/code&gt; 函数（内部根据读入的数据大小，选择调用对应次数的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;WRITE_SERIAL&lt;/code&gt; 函数）。对于串口地址、串口检验地址等常量均定义在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;include/serial.h&lt;/code&gt;中。&lt;/p&gt;

&lt;p&gt;而 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;WRITE_SERIAL&lt;/code&gt; 和  &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;READ_SERIAL&lt;/code&gt; 的核心内容，总结如下：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;判断检验位：将判断地址&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0x10000005&lt;/code&gt;处的数据通过&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;lb&lt;/code&gt;指令读到&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;t1&lt;/code&gt;寄存器中，再通过&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;andi&lt;/code&gt;运算（&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;WRITE_SERIAL&lt;/code&gt;中为&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;t1 = t1 &amp;amp; COM_LSR_THRE = t1 &amp;amp; 0x20&lt;/code&gt; 即 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;t1 = t1 &amp;amp; 0b00100000&lt;/code&gt;截取第&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;5&lt;/code&gt;位检验位是否可写；&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;READ_SERIAL&lt;/code&gt;中为&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;t1 = t1 &amp;amp; COM_LSR_DR = t1 &amp;amp; 0x01&lt;/code&gt;即 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;t1 = t1 &amp;amp; 0b00000001&lt;/code&gt;截取第&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1&lt;/code&gt;为检验位是否可读）截取检验位并判断是否可写/可读（可写/可读计算为1，不可写/不可读为0）；&lt;/li&gt;
  &lt;li&gt;根据检验位的合法性决定下一步执行动作（条件跳转&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bne&lt;/code&gt;）：若检验位不合法（为0）则通过循环判断检验位代码的方法实现“忙等待”，不断“轮询串口状态”直到合法（为1）；若检验位合法（为1）则直接顺序执行后面的代码（真正执行读/写到串口的代码）；&lt;/li&gt;
  &lt;li&gt;读/写：通过&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sb&lt;/code&gt;（&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;WRITE_SERIAL&lt;/code&gt;，写）、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;lb&lt;/code&gt;（&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;READ_SERIAL&lt;/code&gt;，读）向/从串口地址&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0x10000000&lt;/code&gt;读/写数据。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这种通过 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sb&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;lb&lt;/code&gt; 等内存访问指令来实现的对于串口的访问，实际是访问的外设寄存器，这种访问方式叫做MMIO（内存映射 IO）。&lt;/p&gt;

&lt;p&gt;在Term中交互主要的代码块在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;term.py&lt;/code&gt;文件里&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;class tcp_wrapper&lt;/code&gt;中定义的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;write&lt;/code&gt;函数与&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;read&lt;/code&gt;函数，函数实现是基于Python的stdlib库中&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;socket&lt;/code&gt;模块的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;send&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;recv&lt;/code&gt;函数。虽然不确定&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;socket&lt;/code&gt;模块的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;send&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;recv&lt;/code&gt;函数具体是如何实现的，但根据Kernel在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;utils.S&lt;/code&gt;中的读 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;READ_SERIAL&lt;/code&gt; /写 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;WRITE_SERIAL&lt;/code&gt; 函数每次只读取/写入&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0x10000000&lt;/code&gt;地址8位数据，推测Term中调用的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;socket&lt;/code&gt;模块的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;send&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;recv&lt;/code&gt;函数也需要判断检验位后每次向串口地址&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0x10000000&lt;/code&gt;读/写8位数据。&lt;/p&gt;

&lt;h2 id=&quot;思考题目&quot;&gt;思考题目&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;比较 RISC-V 指令寻址方法与 x86 指令寻址方法的异同。&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;RISC-V指令寻址方法只有一种（立即数与存放基址的寄存器相加，即基址+偏移量寻址），而x86指令寻址方法繁多（包含立即数寻址、寄存器寻址、绝对寻址、间接寻址、基址+偏移量寻址、2种变址寻址、4种比例变址寻址）。&lt;/p&gt;

    &lt;p&gt;RISC-V只有load, store访存指令（&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;lb&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;lw&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sb&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sw&lt;/code&gt;等）可以访问内存，而x86基本所有指令（如移动指令&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mov&lt;/code&gt;、算术指令&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;add&lt;/code&gt;等，以及x86本身的访存指令）均可以访问内存。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;阅读监控程序，列出监控程序的 19 条指令，请根据自己的理解对用到的指令进行分类，并说明分类原因。&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;19条指令（参考了&lt;em&gt;《RISC-V手册》&lt;/em&gt;）：&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: left&quot;&gt;指令&lt;/th&gt;
          &lt;th style=&quot;text-align: left&quot;&gt;描述&lt;/th&gt;
          &lt;th style=&quot;text-align: left&quot;&gt;具体含义&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;&lt;strong&gt;add&lt;/strong&gt; rd, rs1, rs2&lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;x[rd] = x[rs1] + x[rs2]&lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;把寄存器 x[rs2]加到寄存器x[rs1]上，结果写入x[rd]（忽略算术溢出）&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;&lt;strong&gt;addi&lt;/strong&gt; rd, rs, imm&lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;x[rd] = x[rs] + sext(imm)&lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;把符号位扩展的立即数加到寄存器x[rs]上，结果写入x[rd]（忽略算术溢出）&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;&lt;strong&gt;and&lt;/strong&gt; rd, rs1, rs2&lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;x[rd] = x[rs1] &amp;amp; x[rs2]&lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;将寄存器 x[rs1]和寄存器x[rs2]位与的结果写入x[rd]&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;&lt;strong&gt;andi&lt;/strong&gt; rd, rs, imm&lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;x[rd] = x[rs] &amp;amp; sext(imm)&lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;把符号位扩展的立即数和寄存器x[rs]上的值进行位与，结果写入x[rd]&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;&lt;strong&gt;auipc&lt;/strong&gt; rd, imm&lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;x[rd] = pc + sext(imm[31:12] « 12)&lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;把符号位扩展的20位（左移12位）立即数加到pc上，结果写入x[rd]&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;&lt;strong&gt;beq&lt;/strong&gt; rs1, rs2, offset&lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;if (x[rs1] == x[rs2]) pc += sext(offset)&lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;若寄存器x[rs1]和寄存器x[rs2]的值相等，把pc的值设为当前值加上符号位扩展的偏移offset&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;&lt;strong&gt;bne&lt;/strong&gt; rs1, rs2, offset&lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;if (x[rs1] ≠ x[rs2]) pc += sext(offset)&lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;若寄存器x[rs1]和寄存器x[rs2]的值不相等，把pc的值设为当前值加上符号位扩展的偏移offset&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;&lt;strong&gt;jal&lt;/strong&gt; rd, offset&lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;x[rd] = pc+4; pc += sext(offset)&lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;把下一条指令的地址(pc+4)写入x[rd]，然后把pc设置为当前值加上符号位扩展的offset&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;&lt;strong&gt;jalr&lt;/strong&gt; rd, offset(rs)&lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;t=pc+4; pc=(x[rs]+sext(offset))&amp;amp;~1; x[rd]=t&lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;把pc设置为x[rs]+sext(offset)，把计算出的地址的最低有效位设为 0，并将原pc+4的值写入x[rd]（rd默认为x1）&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;&lt;strong&gt;lb&lt;/strong&gt; rd, offset(rs)&lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;x[rd] = sext(M[x[rs] + sext(offset)][7:0])&lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;从地址x[rs]+sext(offset)读取一个字节（8位），经符号位扩展后写入x[rd]&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;&lt;strong&gt;lui&lt;/strong&gt; rd, imm&lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;x[rd] = sext(imm[31:12] « 12)&lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;将符号位扩展的20位立即数imm左移12位，写入x[rd]中（低12位置零）&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;&lt;strong&gt;lw&lt;/strong&gt; rd, offset(rs)&lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;x[rd] = sext(M[x[rs] + sext(offset)][31:0])&lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;从地址x[rs]+sext(offset)读取四个字节，写入x[rd]&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;&lt;strong&gt;or&lt;/strong&gt; rd, rs1, rs2&lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;x[rd] = x[rs1] | x[rs2]&lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;把寄存器x[rs1]和寄存器x[rs2]按位取或，结果写入x[rd]&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;&lt;strong&gt;ori&lt;/strong&gt; rd, rs, imm&lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;x[rd] = x[rs] | sext(imm)&lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;把寄存器x[rs]和符号扩展的立即数imm按位取或，结果写入x[rd]&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;&lt;strong&gt;sb&lt;/strong&gt; rs2, offset(rs1)&lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;M[x[rs1] + sext(offset)] = x[rs2][7:0]&lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;将x[rs2]的低8位存入内存地址x[rs1]+sext(offset)&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;&lt;strong&gt;slli&lt;/strong&gt; rd, rs, shamt&lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;x[rd] = x[rs] « shamt&lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;把寄存器x[rs]逻辑左移shamt位，空出的位置填入0，结果写入x[rd]（对于RV32I，仅当shamt[5]=0时，指令才有效）&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;&lt;strong&gt;srli&lt;/strong&gt; rd, rs, shamt&lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;x[rd] = x[rs] » shamt&lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;把寄存器x[rs]逻辑右移shamt位，空出的位置填入0，结果写入x[rd]（对于RV32I，仅当shamt[5]=0时，指令才有效）&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;&lt;strong&gt;sw&lt;/strong&gt; rs2, offset(rs1)&lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;M[x[rs1] + sext(offset)] = x[rs2][31:0]&lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;将x[rs2]的低位4个字节存入内存地址x[rs1]+sext(offset)&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;&lt;strong&gt;xor&lt;/strong&gt; rd, rs1, rs2&lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;x[rd] = x[rs1] ^ x[rs2]&lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;x[rs1]和x[rs2]按位异或，结果写入x[rd]&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;blockquote&gt;
      &lt;p&gt;&lt;em&gt;x[id]表示编号为id的寄存器，rd表示destination register目标寄存器的编号，rs表示source register源寄存器的编号，sext表示sign-extend符号位扩展，imm表示immediate立即数，pc表示program counter程序计数器寄存器，offset为立即数形式的偏移量，M[address]表示地址为address的内存空间，shamt为立即数形式的位移量。&lt;/em&gt;&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;p&gt;分类：&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th&gt;分类&lt;/th&gt;
          &lt;th&gt;指令&lt;/th&gt;
          &lt;th&gt;原因&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;整数计算指令&lt;/td&gt;
          &lt;td&gt;ADD, ADDI, AND, ANDI, SLLI, SRLI, OR, ORI, XOR, LUI, AUIPC&lt;/td&gt;
          &lt;td&gt;需要调用ALU，包含算术指令（ADD, ADDI）、逻辑指令（AND, ANDI, OR, ORI, XOR）、移位指令（SLLI, SRLI）、其他（向PC高位加上立即数的AUIPC, 加载立即数到高位的LUI）&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;条件分支指令&lt;/td&gt;
          &lt;td&gt;BEQ, BNE&lt;/td&gt;
          &lt;td&gt;根据比较结果进行分支跳转&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;无条件跳转指令&lt;/td&gt;
          &lt;td&gt;JAL, JALR&lt;/td&gt;
          &lt;td&gt;实现无条件的跳转并链接&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;访存指令&lt;/td&gt;
          &lt;td&gt;LB, LW, SB, SW&lt;/td&gt;
          &lt;td&gt;从/向内存加载、存储数据&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;结合 term 源代码和 kernel 源代码说明 term 是如何实现用户程序计时的。&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;主要思路是，Kernel获得用户程序地址后通过串口发送开始计时信号&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SIG_TIMERSET&lt;/code&gt;来通知Term用户程序开始运行，Term处开始计时（记录开始时间），Kernel执行完用户程序并复原调用用户代码前的寄存器、栈顶指针后通过串口发送停止计时信号&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SIG_TIMETOKEN&lt;/code&gt;来通知Term用户程序结束运行，Term处停止计时并获得用户程序运行时间（计算结束时间与先前记录的开始时间之差）。&lt;/p&gt;

    &lt;p&gt;具体流程为：&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;Term在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;term.py&lt;/code&gt;文件中的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;run_G&lt;/code&gt;函数中，将指令&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;G&lt;/code&gt;与用户程序代码所在的8位内存地址通过串口写给Kernel；&lt;/li&gt;
      &lt;li&gt;Kernel在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;shell.S&lt;/code&gt;文件的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SHELL&lt;/code&gt;函数中从串口中读入Term发来的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;G&lt;/code&gt;指令并跳转到&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.OP_G&lt;/code&gt;子函数中，再从串口中读入Term发来的用户程序代码所在的8位内存地址并保存到&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;s10&lt;/code&gt;寄存器，然后在执行用户程序（跳转到&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;s10&lt;/code&gt;所存内存地址处）之前，通过串口向Term写入开始计时信号&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SIG_TIMERSET&lt;/code&gt;（即&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0x06&lt;/code&gt;，在ASCII中表示ACK，为不可见ASCII字符）；&lt;/li&gt;
      &lt;li&gt;Term通过串口读入Kernel发来的数据，并判断是否为约定好的开始计时信号&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SIG_TIMERSET&lt;/code&gt;（即&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0x06&lt;/code&gt;），若是则通过&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;time_start = timer()&lt;/code&gt;开始计时（记录开始时间）；&lt;/li&gt;
      &lt;li&gt;Kernel此时写入返回地址&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;la ra, .USERRET2&lt;/code&gt;到&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ra&lt;/code&gt;后开始执行用户程序，即&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;jr s10&lt;/code&gt;跳转到用户程序所在的内存地址&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;s10&lt;/code&gt;处，同时Term通过&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;while True:&lt;/code&gt;循环不断判断从串口处读入的数据是否是约定好的停止计时信号&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SIG_TIMETOKEN&lt;/code&gt;（即&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0x07&lt;/code&gt;，在ASCII中表示BEL，为不可见ASCII字符）——&lt;/li&gt;
      &lt;li&gt;若Term读入的不是停止计时信号&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SIG_TIMETOKEN&lt;/code&gt;（且也不是超时信号&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SIG_TIMEOUT&lt;/code&gt;即&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0x81 &lt;/code&gt;）则默认为Kernel向Term发送的待输出到终端的可见字符，调用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;output_binary&lt;/code&gt;函数将其输出到终端；&lt;/li&gt;
      &lt;li&gt;直到Kernel执行完用户程序（进入&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.USERRET2&lt;/code&gt;子函数并完成调用用户程序之前的寄存器、栈顶指针复原），通过串口向Term写入停止计时信号&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SIG_TIMETOKEN&lt;/code&gt;；&lt;/li&gt;
      &lt;li&gt;因此此时Term再通过&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;while&lt;/code&gt;循环从串口读入的就是停止计时信号&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SIG_TIMETOKEN&lt;/code&gt;（即&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0x07&lt;/code&gt;），终止&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;while&lt;/code&gt;循环并通过&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;elapse = timer() - time_start&lt;/code&gt;停止计时并获得用户程序运行时间（计算结束时间与先前记录的开始时间之差）。&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;说明 kernel 是如何使用串口的（在源代码中，这部分有针对 FPGA 与 QEMU 两个版本的代码，任选其一进行分析即可）。&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;如&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;supervisor-rv/kernel/include/serial.h&lt;/code&gt;文件中定义的，FPGA与QEMU的串口地址常量均由&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;COM1&lt;/code&gt;表示、串口的寄存器地址间隔均由&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;COM_MULTIPLY&lt;/code&gt;表示、串口是否可读/可写的判断地址相对于串口地址的偏移量均由&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;COM_LSR_OFFSET&lt;/code&gt;表示（即判断可读/可写状态位的判断地址实际为&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;COM1 + COM_LSR_OFFSET&lt;/code&gt;）、写状态位均由&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;COM_LSR_THRE&lt;/code&gt;表示、读状态位均由&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;COM_LSR_DR&lt;/code&gt;表示。&lt;/p&gt;

    &lt;p&gt;详见上一章代码分析报告中&lt;a href=&quot;#1&quot;&gt;交互流程&lt;/a&gt;一节，以QEMU为例（即&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;COM1 = 0x10000000&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;COM_MULTIPLY = 1&lt;/code&gt;, ` COM_LSR_OFFSET = 5&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;, &lt;/code&gt;COM_LSR_THRE = 0x20&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;, &lt;/code&gt;COM_LSR_DR = 0x01&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;）分析了Kernel如何使用串。（FPGA相应的各常量为&lt;/code&gt;COM1 = AXI Uart16550的基地址 + 0x10000&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;, &lt;/code&gt;COM_MULTIPLY = 4&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;, &lt;/code&gt; COM_LSR_OFFSET = 20&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;, &lt;/code&gt;COM_LSR_THRE = 0x20&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;, &lt;/code&gt;COM_LSR_DR = 0x01`）。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;请问 term 如何检查 kernel 已经正确连入，并分别指出检查代码在 term 与 kernel 源码中的位置。&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;检查代码在Term源码中的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;term.py&lt;/code&gt;文件&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;main&lt;/code&gt;函数调用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;InitializeTCP&lt;/code&gt;函数中&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ser.connect(host, int(port))&lt;/code&gt;语句，其中&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ser&lt;/code&gt;是类&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;tcp_wrapper&lt;/code&gt;的对象，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;tcp_wrapper&lt;/code&gt;的成员函数&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;connect&lt;/code&gt;内部实际上调用了Python的stdlib库中socket模块所定义的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;connect&lt;/code&gt;函数。&lt;/p&gt;

    &lt;p&gt;检查代码在Kernel源码中的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;shell.S&lt;/code&gt;文件&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SHELL&lt;/code&gt;函数&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;li a0, XLEN&lt;/code&gt;与&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;jal WRITE_SERIAL&lt;/code&gt;指令（后续又跳转到&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;utils.S&lt;/code&gt;文件&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;WRITE_SERIAL&lt;/code&gt;函数以将&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;XLEN&lt;/code&gt;写入串口给Term）。&lt;/p&gt;

    &lt;p&gt;Term如何检查Kernel已经正确连入，分析如下——&lt;/p&gt;

    &lt;p&gt;观察Term连接Kernel的过程：&lt;/p&gt;

    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;➜  kernel git:&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;master&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; ✗ make sim
riscv64-unknown-elf-ld  obj/evec.o  obj/init.o  obj/shell.o  obj/test.o  obj/trap.o  obj/utils.o &lt;span class=&quot;nt&quot;&gt;-Tkern&lt;/span&gt;/kernel32.ld
qemu-system-riscv32 &lt;span class=&quot;nt&quot;&gt;-M&lt;/span&gt; virt &lt;span class=&quot;nt&quot;&gt;-m&lt;/span&gt; 32M &lt;span class=&quot;nt&quot;&gt;-kernel&lt;/span&gt; kernel.elf &lt;span class=&quot;nt&quot;&gt;-nographic&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-monitor&lt;/span&gt; none &lt;span class=&quot;nt&quot;&gt;-serial&lt;/span&gt; tcp::6666,server &lt;span class=&quot;nt&quot;&gt;-s&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-bios&lt;/span&gt; none
qemu-system-riscv32: &lt;span class=&quot;nt&quot;&gt;-serial&lt;/span&gt; tcp::6666,server: info: QEMU waiting &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;connection on: disconnected:tcp::::6666,server&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;on
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;➜  term git:&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;master&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; ✗ python3 term.py &lt;span class=&quot;nt&quot;&gt;-t&lt;/span&gt; 127.0.0.1:6666
connecting to 127.0.0.1:6666...connected
MONITOR &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;RISC-V - initialized.
running &lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;32bit, xlen &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; 4
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;完整连接过程（包含&lt;strong&gt;检查是否正确连入&lt;/strong&gt;）分为以下几步：&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;一旦启动Kernel（执行&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;make sim&lt;/code&gt;指令），Kernel就已经完成&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;evec.S&lt;/code&gt;与&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;init.S&lt;/code&gt;中代码的运行（此处包含①各种必要的初始化，②通过模拟器QEMU设置好的host为本机、端口为&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;6666&lt;/code&gt;的TCP服务器以等待Term的连接并配置好串口，③以及向串口写入定义为&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;monitor_version&lt;/code&gt;的文本数据&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&quot;MONITOR for RISC-V - initialized.&quot;&lt;/code&gt;——注意此处只是向串口写入，Term并没有读取该数据，Term甚至还没有连接上Kernel呢），并进入&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;shell.S&lt;/code&gt;中&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SHELL&lt;/code&gt;函数中，第一行的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;jal READ_SERIAL&lt;/code&gt;跳转到&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;utils.S&lt;/code&gt;的读操作符函数中，忙等待Term在连接上Kernel之后通过串口向Kernel发送操作符&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;W&lt;/code&gt;，好让Kernel通过串口把&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;XLEN&lt;/code&gt;写给Term（注意此处Kernel一直卡在函数&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;READ_SERIAL&lt;/code&gt;中的子函数&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.TESTR&lt;/code&gt;进行轮询检测验证，因为Term此时还没给Kernel发送任何数据，因此串口检测地址的可读位始终为0，Term甚至还没连接上Kernel呢）；&lt;/li&gt;
      &lt;li&gt;反观Term，由用户在终端敲入&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;python3 term.py -t 127.0.0.1:6666&lt;/code&gt;命令，Term在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;term.py&lt;/code&gt;的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;main&lt;/code&gt;函数中通过&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;args = parser.parse_args()&lt;/code&gt;从命令行读入&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;args.tcp = 127.0.0.1:6666 &lt;/code&gt;，并作为参数&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;host_port&lt;/code&gt;传入&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;InitializeTCP(host_port)&lt;/code&gt;函数；&lt;/li&gt;
      &lt;li&gt;在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;InitializeTCP&lt;/code&gt;函数中，若用户输入的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;host_port&lt;/code&gt;不满足&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;host&lt;/code&gt;与&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;port&lt;/code&gt;的正则表达式，则直接返回到&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;main&lt;/code&gt;函数中输出&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;print('Failed to establish TCP connection')&lt;/code&gt;退出程序，也就是完全没有执行任何连接相关操作；&lt;/li&gt;
      &lt;li&gt;若用户输入的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;host_port&lt;/code&gt;在语法上是合法的，则Term创建&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;tcp_wrapper&lt;/code&gt;类的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ser = tcp_wrapper()&lt;/code&gt;对象，在终端输出&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&quot;connecting to 127.0.0.1:6666...&quot;&lt;/code&gt;，并调用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;socket&lt;/code&gt;模块（Python的stdlib库自带模块）的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ser.connect(host, int(port))&lt;/code&gt;连接函数进行连接与&lt;strong&gt;检查是否正确连入&lt;/strong&gt;的操作（若连接成功则顺序执行&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;print(&quot;connected&quot;)&lt;/code&gt;输出连接成功，若连接失败则由&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;socket&lt;/code&gt;库的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;connect&lt;/code&gt;函数提供报错信息如&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ConnectionRefusedError: [Errno 61] Connection refused&lt;/code&gt;并退出程序）；&lt;/li&gt;
      &lt;li&gt;连接成功后（终端输出&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&quot;connected&quot;&lt;/code&gt;），Term跳转到&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Main&lt;/code&gt;函数，通过&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;inp.read&lt;/code&gt;从串口中读入步骤1.中Kernel往串口中写入的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;monitor_version&lt;/code&gt;文本数据，并打印在终端；&lt;/li&gt;
      &lt;li&gt;然后Term再向串口&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;outp.write(b'W')&lt;/code&gt;写入操作符&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;W&lt;/code&gt;，如步骤1.所提到的，Kernel在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;READ_SERIAL&lt;/code&gt;函数中的子函数&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.TESTR&lt;/code&gt;轮询进行检测验证，终于验证到了可读位为1（因为Term终于向Kernel发送了数据&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;W&lt;/code&gt;，串口检测地址的可读位从0变成1），顺序执行读取操作符&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;W&lt;/code&gt;，并返回到&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SHELL&lt;/code&gt;函数中，执行&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;li a0, XLEN&lt;/code&gt;与&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;jal WRITE_SERIAL&lt;/code&gt;，即将机器字长&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;XLEN&lt;/code&gt;（版本号）通过串口写给Term，该功能作为&lt;strong&gt;检查是否正确连入&lt;/strong&gt;的标志，之后Kernel将等待Term从串口发来的Term命令；&lt;/li&gt;
      &lt;li&gt;Term读取串口&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;xlen = ord(inp.read(1))&lt;/code&gt;获得机器字长并输出到终端&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&quot;running in 32bit, xlen = 4&quot;&lt;/code&gt;，随后进入&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MainLoop&lt;/code&gt;函数由用户输入Term命令，后续再与Kernel交互，不再阐释。&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ol&gt;</content><author><name>Hanna Wang</name></author><category term="posts" /><category term="computer-science" /><category term="blog" /><summary type="html">实验报告</summary></entry><entry><title type="html">首条博客：网站创建成功~</title><link href="https://hanna0911.github.io/posts/first-blog/" rel="alternate" type="text/html" title="首条博客：网站创建成功~" /><published>2022-09-17T12:54:07+00:00</published><updated>2022-09-17T18:58:54+00:00</updated><id>https://hanna0911.github.io/posts/first-blog</id><content type="html" xml:base="https://hanna0911.github.io/posts/first-blog/">&lt;p&gt;并没有什么内容的博客哈哈，贴一下老师的&lt;a href=&quot;https://book.ncrnalab.org/teaching/getting-started&quot;&gt;作业要求&lt;/a&gt;吧！&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;注册一个GitHub账户，创建一个&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;repo&lt;/code&gt;(仓库)，写好&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;README.md&lt;/code&gt;。尝试使用Git（初学者可以用github的&lt;a href=&quot;https://desktop.github.com/&quot;&gt;桌面版软件&lt;/a&gt;）管理自己的代码并同步GitHub云端和本地文件。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;尝试使用Markdown语言，熟悉其语法，利用github的github page功能，用markdown写一个自己的网页。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;</content><author><name>Hanna Wang</name></author><category term="posts" /><category term="nothing" /><category term="blog" /><summary type="html">并没有什么内容的博客哈哈，贴一下老师的作业要求吧！</summary></entry></feed>